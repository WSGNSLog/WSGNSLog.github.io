<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Stay Hungry,Stay Foolish.">
<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="Stay Hungry,Stay Foolish.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="个人博客">
<meta name="twitter:description" content="Stay Hungry,Stay Foolish.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'NSLegend'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>个人博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Stay Hungry,Stay Foolish.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/21/6-Block底层解密/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NSLegend">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/21/6-Block底层解密/" itemprop="url">6.Block底层解密</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-21T10:22:20+08:00">
                2018-12-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS底层/" itemprop="url" rel="index">
                    <span itemprop="name">iOS底层</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void (^block)(void) =  ^()&#123;</span><br><span class="line">NSLog(@&quot;this is a block!&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样一个简单的<code>block</code>块大家都应该知道吧，但是这个<code>block</code>块是怎么实现的呢？</p>
<p>想要了解OC对象主要是基于C/C++的什么数据结构实现的，我们首先要做的就是将Object-C代码转化为C/C++代码，这样我们才能清楚的看清是怎么实现的</p>
<p>然后我们打开终端，在命令行找到cd到文件目录，然后中输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc main.m</span><br></pre></td></tr></table></figure></p>
<p>执行结束以后，会生成<code>main.cpp</code>文件，我们打开<code>main.cpp</code>文件，拉到最下边就是我们的<code>main</code>函数实现的。</p>
<p>我们得到c++代码的block实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br></pre></td></tr></table></figure></p>
<p>我们知道<code>(void *)</code>这种类型的都是类型的强制转换，为了更好的识别我们的这个Block代码，我们把类型转化去掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void (*block)(void) = &amp;__main_block_impl_0(__main_block_func_0,</span><br><span class="line">&amp;__main_block_desc_0_DATA));</span><br></pre></td></tr></table></figure></p>
<p>我们在分别查询<code>__main_block_impl_0</code>,<code>__main_block_func_0</code>,<code>__main_block_desc_0_DATA</code>代表什么意思</p>
<p><strong>__main_block_impl_0</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">struct __block_impl impl;</span><br><span class="line">struct __main_block_desc_0* Desc;</span><br><span class="line">// 构造函数（类似于OC的init方法），返回结构体对象</span><br><span class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">impl.Flags = flags;</span><br><span class="line">impl.FuncPtr = fp;</span><br><span class="line">Desc = desc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们查看一下<code>__block_impl</code>里面是什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">void *isa;</span><br><span class="line">int Flags;</span><br><span class="line">int Reserved;</span><br><span class="line">void *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>__main_block_func_0</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 封装了block执行逻辑的函数</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_2r__m13fp2x2n9dvlr8d68yry500000gn_T_main_c60393_mi_0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>__main_block_desc_0_DATA</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">size_t reserved;</span><br><span class="line">size_t Block_size;//内存大小描述</span><br><span class="line">&#125; __main_block_desc_0_DATA</span><br></pre></td></tr></table></figure></p>
<p>所以我们可以总结</p>
<ul>
<li>1、<code>__main_block_impl_0</code>中<code>__block_impl</code>存放的是一些变量信息，其中存在<code>isa</code>，所以可以判断block的本质其实就是OC对象</li>
<li>2、初始化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">impl.Flags = flags;</span><br><span class="line">impl.FuncPtr = fp;</span><br><span class="line">Desc = desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我们在来查看Block方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void (*block)(void) = &amp;__main_block_impl_0(__main_block_func_0,</span><br><span class="line">&amp;__main_block_desc_0_DATA));</span><br></pre></td></tr></table></figure></p>
<p>对应上面的初始化我们可以看出第一个参数传递的是<code>执行方法</code>，第二个参数为<code>描述信息</code></p>
<p><strong>Block底层结构图</strong><br><img src="/2018/12/21/6-Block底层解密/Block1.png" title="Block1"></p>
<h3 id="成员变量的捕获"><a href="#成员变量的捕获" class="headerlink" title="成员变量的捕获"></a>成员变量的捕获</h3><p>为了保证block内部能够正常的访问外部变量，block有个变量捕获机制,这里我们先说结果，然后在进行证明</p>
<img src="/2018/12/21/6-Block底层解密/Block2.png" title="Block2">
<p>我们在<code>main</code>函数写下这些代码，然后在把<code>main</code>函数生成c++代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">int height = 180;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int age = 10;</span><br><span class="line">static int weight = 65;</span><br><span class="line">void (^block)(void) =  ^()&#123;</span><br><span class="line">NSLog(@&quot;age---------%d&quot;,age);</span><br><span class="line">NSLog(@&quot;weight---------%d&quot;,weight);</span><br><span class="line">NSLog(@&quot;height---------%d&quot;,height);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们直接找到c++代码里面存放变量的结构体<code>__main_block_impl_0</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">struct __block_impl impl;</span><br><span class="line">struct __main_block_desc_0* Desc;</span><br><span class="line">int age;</span><br><span class="line">int *weight;</span><br><span class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int *_weight, int flags=0) : age(_age), weight(_weight) &#123;</span><br><span class="line">impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">impl.Flags = flags;</span><br><span class="line">impl.FuncPtr = fp;</span><br><span class="line">Desc = desc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到变量捕获为<code>age</code>,<code>*weight</code>,但是没有捕获到全局变量<code>height</code>。为了方便的理解，我们先来了解一些内存空间的分配。</p>
<ul>
<li>1、栈区(stack) 由编译器自动分配并释放，存放函数的参数值，局部变量等。栈空间分静态分配 和动态分配两种。静态分配是编译器完成的，比如自动变量(auto)的分配。动态分配由alloca函数完成。</li>
<li>2、堆区(heap) 由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回收 ，比如在ios 中 alloc 都是存放在堆中。</li>
<li>3、全局区(静态区) (static) 全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后有系统释放。</li>
<li>4、程序代码区 存放函数的二进制代码</li>
</ul>
<p>总结：</p>
<ul>
<li>1、因为自动变量(auto)分配的内存空间在<code>栈区(stack)</code>，编译器会自动帮我们释放，如果我们把block写在另外一个方法中调用，自动变量<code>age</code>就会被释放，block在使用的时候就已经被释放了，所以需要重新copy一下</li>
<li>2、静态变量在程序结束后有系统释放，所以不需要担心被释放，block只需要知道他的内存地址就行</li>
<li>3、对于全局变量，任何时候都可以直接访问，所以根本就不需要捕获</li>
</ul>
<h3 id="Block类型"><a href="#Block类型" class="headerlink" title="Block类型"></a>Block类型</h3><p>block有3种类型，可以通过调用class方法或者isa指针查看具体的类型，但是最终都是继承者NSBlock类型</p>
<ul>
<li>1、<strong>NSGlobalBlock</strong>，没有访问auto变量</li>
<li>2、<strong>NSStackBlock</strong>，访问了auto变量</li>
<li>3、<strong>NSMallocBlock</strong>，<strong>NSStackBlock</strong>调用了copy方法</li>
</ul>
<p>她们的内存分配<br><img src="/2018/12/21/6-Block底层解密/Block3.png" title="Block3"></p>
<p>每一种类型的Block调用copy后的结果</p>
<ul>
<li>1、<strong>NSStackBlock</strong>原来在栈区，copy以后从栈复制到堆</li>
<li>2、<strong>NSGlobalBlock</strong>原来在程序的数据段，copy以后什么也不做</li>
<li>3、<strong>NSMallocBlock</strong>原来在堆区，复制以后引用计数加1<br>我们来写一小段代码证明一下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void (^block1)(void) =  ^()&#123;</span><br><span class="line">NSLog(@&quot;block1&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">int age = 10;</span><br><span class="line">void (^block2)(void) =  ^()&#123;</span><br><span class="line">NSLog(@&quot;block2&quot;);</span><br><span class="line">NSLog(@&quot;age---------%d&quot;,age);</span><br><span class="line">&#125;;</span><br><span class="line">void (^block3)(void) = [ ^()&#123;</span><br><span class="line">NSLog(@&quot;block3&quot;);</span><br><span class="line">NSLog(@&quot;age---------%d&quot;,age);</span><br><span class="line">&#125; copy];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;block1:%@----&gt;block2:%@-----&gt;block3:%@&quot;,[block1 class],[block2 class],[block3 class]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>打印结果为<br><img src="/2018/12/21/6-Block底层解密/Block4.png" title="Block4"></p>
<p>为什么<code>block2</code>打印类型为<code>__NSMallocBlock__</code>,而不是<code>__NSStackBlock__</code>，因为ARC环境导致了，ARC会自动帮我们copy了一下<code>__NSStackBlock__</code></p>
<h3 id="auto变量修饰符-weak"><a href="#auto变量修饰符-weak" class="headerlink" title="auto变量修饰符__weak"></a>auto变量修饰符__weak</h3><p>在开始之前，我先说一下结论，然后我们在去印证</p>
<ul>
<li>1、当Block内部访问了auto变量时，如果block是在栈上，将不会对auto变量产生强引用</li>
<li>2、如果block被拷贝到堆上，会根据auto变量的修饰符（<strong>strong，</strong>weak，__unsafe_unretained），对auto变量进行强引用或者弱引用</li>
<li>3、如果block从堆上移除的时候，会调用block内部的dispose函数，该函数自动释放auto变量</li>
<li>4、在多个block相互嵌套的时候，auto属性的释放取决于最后的那个强引用什么时候释放</li>
</ul>
<p>下面我们把ARC环境变成MRC环境，同时稍微修改一下代码，我们在看看<code>dealloc</code>什么时候打印<br><code>选择项目 Target -&gt; Build Sttings -&gt; All -&gt; 搜索‘automatic’ -&gt; 把 Objective-C Automatic Reference Counting 设置为 NO</code></p>
<p>我们写一个<code>Person</code>类，在MRC环境，重写<code>dealloc</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc&#123;</span><br><span class="line">[super dealloc];</span><br><span class="line">NSLog(@&quot;person---&gt;dealloc&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们在<code>main</code>函数里面写下这个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line">[p release];</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;--------&quot;);</span><br></pre></td></tr></table></figure></p>
<p>我们肯定都知道打印结果吧：先打印<code>person---&gt;dealloc</code>，然后打印<code>--------</code></p>
<p>如果我们添加一个Block呢,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^Block)(void);</span><br><span class="line"></span><br><span class="line">Block block;</span><br><span class="line">&#123;</span><br><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line">block = ^&#123;</span><br><span class="line">NSLog(@&quot;%@&quot;,p);</span><br><span class="line">&#125;;</span><br><span class="line">[p release];</span><br><span class="line">&#125;</span><br><span class="line">block();</span><br><span class="line">NSLog(@&quot;--------&quot;);</span><br></pre></td></tr></table></figure></p>
<p>打印结果为<br><img src="/2018/12/21/6-Block底层解密/Block5.png" title="Block5"></p>
<p>在ARC环境下，代码稍微的改变一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Block block;</span><br><span class="line">&#123;</span><br><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line">block = ^&#123;</span><br><span class="line">NSLog(@&quot;%@&quot;,p);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">block();</span><br><span class="line">NSLog(@&quot;--------&quot;);</span><br></pre></td></tr></table></figure></p>
<p>打印结果为<br><img src="/2018/12/21/6-Block底层解密/Block6.png" title="Block6"></p>
<p><strong>注意打印顺序：</strong></p>
<ul>
<li>MRC环境下，是先打印<code>dealloc</code>，然后在打印<code>p</code>的</li>
<li>ARC环境下，是先打印<code>p</code>，然后在打印<code>dealloc</code>的</li>
</ul>
<p><code>当Block内部访问了auto变量时，如果block是在栈上，将不会对auto变量产生强引用,因为当Block在栈上的时候，他自己都不能保证自己什么时候被释放，所以block也就不会对自动变量进行强引用了</code></p>
<p>在ARC环境下如果我们对自动变量进行一些修饰符，那么block对auto变量是进行怎么引用呢<br>我们还是老方法，把main文件转化为c++文件，我们找到<code>__main_block_func_0</code>执行函数，</p>
<ul>
<li>当不用修饰符修饰的时：<code>Person *p = __cself-&gt;p; // bound by copy</code></li>
<li>当使用<code>__strong</code>修饰时：<code>Person *strongP = __cself-&gt;strongP; // bound by copy</code></li>
<li>当使用<code>__weak</code>修饰的时:<code>Person *__weak weakP = __cself-&gt;weakP; // bound by copy</code><br>我们运行<code>xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc main.m</code>出错了，我们需要支持ARC，指定运行时系统版本，<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</code></li>
</ul>
<p><strong><em><code>Block会自动copy自动变量的修饰属性</code></em></strong></p>
<h3 id="Block修饰"><a href="#Block修饰" class="headerlink" title="__Block修饰"></a>__Block修饰</h3><p>我们都知道想要修改Block外边的变量，我们都会用<code>__Block</code>来修饰自动变量，但是为什么使用<code>__Block</code>修饰就可以在Block内部来更改自动变量了呢。</p>
<p>我们先写一小段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__block int age = 10;</span><br><span class="line">NSLog(@&quot;block前age地址1：%p&quot;,&amp;age);</span><br><span class="line">Block block = ^&#123;</span><br><span class="line">age = 20;</span><br><span class="line">NSLog(@&quot;block内%d--&gt;age地址2：%p&quot;,age,&amp;age);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br><span class="line">NSLog(@&quot;block后%d--&gt;age地址3：%p&quot;,age,&amp;age);</span><br></pre></td></tr></table></figure></p>
<p>打印结果为</p>
<img src="/2018/12/21/6-Block底层解密/Block7.png" title="Block7">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据内存地址变化可见，__block所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。</span><br></pre></td></tr></table></figure>
<p>我们把<code>main</code>函数转化为C++代码，然后在age使用<code>__Block</code>前后，对Block结构体进行分析</p>
<img src="/2018/12/21/6-Block底层解密/Block8.png" title="Block8">
<p>在<code>__Block</code>所起到的作用就是只要观察到该变量被 block 所持有之后，<code>age</code>其实变成了OC对象，里面含有<code>isa</code>指针</p>
<p><strong>__Block的内存管理原则</strong></p>
<ul>
<li>1、当Block在栈上的时候，并不会对<code>__Block</code>变量进行强饮用</li>
<li>2、当当block被copy到堆时,会调用block内部的copy函数,copy函数内部会调用_Block_object_assign函数,_Block_object_assign函数会对__block变量形成强引用（retain）</li>
<li>3、当block从堆中移除时，会调用block内部的dispose函数，dispose函数内部会调用_Block_object_dispose函数，_Block_object_dispose函数会自动释放引用的__block变量（release)</li>
</ul>
<img src="/2018/12/21/6-Block底层解密/Block9.png" title="Block9">
<img src="/2018/12/21/6-Block底层解密/Block10.png" title="Block10">
<img src="/2018/12/21/6-Block底层解密/Block11.png" title="Block11">
<p>我们先看到了结果，这里我们在来分析一下源码<br><code>__block int age = 10;</code>转化为C++代码，会变成这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((__blocks__(byref))) __Block_byref_age_0 age = &#123;(void*)0,(__Block_byref_age_0 *)&amp;age, 0, sizeof(__Block_byref_age_0), 10&#125;;</span><br><span class="line"></span><br><span class="line">//为了便于观察，我们可以将强制转化去掉</span><br><span class="line">__Block_byref_age_0 age = &#123;</span><br><span class="line">0,</span><br><span class="line">&amp;age,</span><br><span class="line">0,</span><br><span class="line">sizeof(__Block_byref_age_0),</span><br><span class="line">10&#125;;</span><br></pre></td></tr></table></figure></p>
<p>唯一我们不太清除的就是<code>__Block_byref_age_0</code>了，我们查找一下发现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*Block)(void);</span><br><span class="line">struct __Block_byref_age_0 &#123;</span><br><span class="line">void *__isa;</span><br><span class="line">__Block_byref_age_0 *__forwarding;</span><br><span class="line">int __flags;</span><br><span class="line">int __size;</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后我们在来查找Block实现代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">__Block_byref_age_0 *age = __cself-&gt;age; // bound by ref</span><br><span class="line"></span><br><span class="line">(age-&gt;__forwarding-&gt;age) = 20;</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_nb_9qtf99yd2qlbx2m97hdjf2yr0000gn_T_main_1757f5_mi_0,(age-&gt;__forwarding-&gt;age));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来查看一下age是怎么变成20的<code>(age-&gt;__forwarding-&gt;age) = 20;</code>，先是找到<code>__forwarding</code>结构体，然后在找到结构提里面的<code>age</code></p>
<p><strong>总结</strong></p>
<ul>
<li>1、在ARC环境下，Block被引用的时候，会被Copy一次，由栈区copy到了堆</li>
<li>2、在Block被copy的时候，Block内部被引用的<code>变量</code>也同样被copy一份到了堆上面</li>
<li>3、被<strong>Block修饰的变量，在被Block引用的时候，会变成结构体也就是OC对象，里面的`</strong>forwarding`也会由栈copy道对上面</li>
<li>4、栈上<strong>block变量结构体中`</strong>forwarding<code>的指针指向堆上面__block变量结构体，堆上__block变量结构体中</code>__forwarding`指针指向自己</li>
<li>5、当block从堆中移除时，会调用block内部的dispose函数，dispose函数内部会调用_Block_object_dispose函数，_Block_object_dispose函数会自动释放引用的__block变量（release)</li>
</ul>
<h3 id="解决循环引用"><a href="#解决循环引用" class="headerlink" title="解决循环引用"></a>解决循环引用</h3><p>我们看了那么长时间的源码了，一定还记得在auto变量为OC对象的时候，在没有修饰符修饰的时候Block内部会强引用OC对象，而对象如果也持有Block的时候就会造成相互引用，也就是循环引用的问题。</p>
<img src="/2018/12/21/6-Block底层解密/Block12.png" title="Block12">
<p>我们也只能在Block持有OC对象的时候，给OC对象添加弱引用修饰符才比较合适，有两个弱引用修饰符<code>__weak</code>和<code>__unsafe_unretained</code></p>
<ul>
<li>1、 __weak：不会产生强引用，指向的对象销毁时，会自动让指针置为nil</li>
<li>2、__unsafe_unretained：不会产生强引用，不安全，指向的对象销毁时，指针存储的地址值不变</li>
</ul>
<p>其实还有一种解决方法，那就是使用<code>__Block</code>,需要在Block内部吧OC对象设置为nil</p>
<img src="/2018/12/21/6-Block底层解密/Block13.png" title="Block13">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__block id weakSelf = self;</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">weakSelf = nil;</span><br><span class="line">&#125;</span><br><span class="line">self.block();</span><br></pre></td></tr></table></figure>
<p>使用<code>__Block</code>解决必须调用Block</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/21/5-2-Load和InitiaLize实现原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NSLegend">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/21/5-2-Load和InitiaLize实现原理/" itemprop="url">5.2 Load和InitiaLize实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-21T10:20:02+08:00">
                2018-12-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS底层/" itemprop="url" rel="index">
                    <span itemprop="name">iOS底层</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Load实现原理"><a href="#Load实现原理" class="headerlink" title="+Load实现原理"></a>+Load实现原理</h3><blockquote>
<p>+load方法会在<code>runtime</code>加载<code>类</code>、<code>分类</code>时调用</p>
</blockquote>
<blockquote>
<p>每个类、分类的+load，在程序运行过程中<code>只调用一次</code></p>
</blockquote>
<blockquote>
<p>+load方法是根据方法<code>地址</code>直接调用，并不是经过objc_msgSend函数调用</p>
</blockquote>
<p><strong>调用顺序</strong></p>
<ul>
<li>1、先调用类的+load<ul>
<li>按照编译先后顺序调用（先编译，先调用）</li>
<li>调用子类的+load之前会先调用父类的+load</li>
</ul>
</li>
<li>2、再调用分类的+load<ul>
<li>按照编译先后顺序调用（先编译，先调用）</li>
</ul>
</li>
</ul>
<p><strong>objc4源码解读过程</strong><br>objc-os.mm 文件</p>
<ul>
<li>_objc_init</li>
<li>load_images</li>
<li>prepare_load_methods<ul>
<li>schedule_class_load</li>
<li>add_class_to_loadable_list</li>
<li>add_category_to_loadable_list</li>
</ul>
</li>
<li>call_load_methods<ul>
<li>call_class_loads</li>
<li>call_category_loads</li>
</ul>
</li>
</ul>
<p><code>_objc_init</code>方法是RunTime运行的入口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">static bool initialized = false;</span><br><span class="line">if (initialized) return;</span><br><span class="line">initialized = true;</span><br><span class="line"></span><br><span class="line">// fixme defer initialization until an objc-using image is found?</span><br><span class="line">environ_init();</span><br><span class="line">tls_init();</span><br><span class="line">static_init();</span><br><span class="line">lock_init();</span><br><span class="line">exception_init();</span><br><span class="line"></span><br><span class="line">_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>小知识：<code>images</code>是镜像的意思</p>
</blockquote>
<p>我们在<code>_objc_init</code>方法中找到<code>load_images</code>，<code>load_images</code>是Load加载镜像的意思，所有我们可以猜测这个里面应该有我们load的加载方法的相关实现</p>
<p>我们点击进入<code>load_images</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">load_images(const char *path __unused, const struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">// Return without taking locks if there are no +load methods here.</span><br><span class="line">if (!hasLoadMethods((const headerType *)mh)) return;</span><br><span class="line"></span><br><span class="line">recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">// Discover load methods</span><br><span class="line">&#123;</span><br><span class="line">rwlock_writer_t lock2(runtimeLock);</span><br><span class="line">prepare_load_methods((const headerType *)mh);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Call +load methods (without runtimeLock - re-entrant)</span><br><span class="line">call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>里面有两个需要我们注意的</p>
<ul>
<li>1、<code>prepare_load_methods((const headerType *)mh)</code>准备加载Load方法，我们也可以看到上面的官方文档解释也是这个意思</li>
<li>2、<code>call_load_methods()</code> 加载load方法</li>
</ul>
<p>我们点击进入<code>prepare_load_methods((const headerType *)mh)</code>准备加载Load方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void prepare_load_methods(const headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">size_t count, i;</span><br><span class="line"></span><br><span class="line">runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">classref_t *classlist = </span><br><span class="line">_getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">category_t *cat = categorylist[i];</span><br><span class="line">Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">if (!cls) continue;  // category for ignored weak-linked class</span><br><span class="line">realizeClass(cls);</span><br><span class="line">assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">add_category_to_loadable_list(cat);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到执行顺序</p>
<ul>
<li>1、<code>schedule_class_load(remapClass(classlist[i]));</code>,这个是把类中的<code>Load</code>方法添加到数组中</li>
<li>2、<code>add_category_to_loadable_list(cat);</code>这个是把分类中的<code>load</code>方法添加到数组中</li>
</ul>
<p><strong>查看类的load方法</strong></p>
<p>我们查看<code>schedule_class_load(remapClass(classlist[i]));</code>方法里面还有哪些实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">if (!cls) return;</span><br><span class="line">assert(cls-&gt;isRealized());  // _read_images should realize</span><br><span class="line"></span><br><span class="line">if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line"></span><br><span class="line">// Ensure superclass-first ordering</span><br><span class="line">schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">add_class_to_loadable_list(cls);</span><br><span class="line">cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1、<code>schedule_class_load(cls-&gt;superclass);</code> 把父类load先添加到数组中</li>
<li>2、<code>add_class_to_loadable_list(cls);</code>把自己的load方法添加到数组中</li>
</ul>
<p>走到这里我们大概是清楚了类中load方法的加载添加过程，就是先把<code>父类添加带数组中，然后再把自己添加到数组中</code></p>
<p><strong>查看分类的load方法</strong></p>
<p>我们点击<code>add_category_to_loadable_list(cat)</code>进入查看方法实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void add_category_to_loadable_list(Category cat)</span><br><span class="line">&#123;</span><br><span class="line">IMP method;</span><br><span class="line"></span><br><span class="line">loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">method = _category_getLoadMethod(cat);</span><br><span class="line"></span><br><span class="line">// Don&apos;t bother if cat has no +load method</span><br><span class="line">if (!method) return;</span><br><span class="line"></span><br><span class="line">if (PrintLoading) &#123;</span><br><span class="line">_objc_inform(&quot;LOAD: category &apos;%s(%s)&apos; scheduled for +load&quot;, </span><br><span class="line">_category_getClassName(cat), _category_getName(cat));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (loadable_categories_used == loadable_categories_allocated) &#123;</span><br><span class="line">loadable_categories_allocated = loadable_categories_allocated*2 + 16;</span><br><span class="line">loadable_categories = (struct loadable_category *)</span><br><span class="line">realloc(loadable_categories,</span><br><span class="line">loadable_categories_allocated *</span><br><span class="line">sizeof(struct loadable_category));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadable_categories[loadable_categories_used].cat = cat;</span><br><span class="line">loadable_categories[loadable_categories_used].method = method;</span><br><span class="line">loadable_categories_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>loadable_categories_used++;</code>分类没有什么特殊的方法，应该就是按照编译顺序添加到数组的。</p>
<p><strong>实现</strong></p>
<p>我们刚才看到了类分类中的添加顺序，我们在来看看加载顺序<br>点击<code>call_load_methods();</code>进入相关实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void call_load_methods(void)</span><br><span class="line">&#123;</span><br><span class="line">static bool loading = NO;</span><br><span class="line">bool more_categories;</span><br><span class="line"></span><br><span class="line">loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">// Re-entrant calls do nothing; the outermost call will finish the job.</span><br><span class="line">if (loading) return;</span><br><span class="line">loading = YES;</span><br><span class="line"></span><br><span class="line">void *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">// 1. Repeatedly call class +loads until there aren&apos;t any more</span><br><span class="line">while (loadable_classes_used &gt; 0) &#123;</span><br><span class="line">call_class_loads();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. Call category +loads ONCE</span><br><span class="line">more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">// 3. Run more +loads if there are classes OR more untried categories</span><br><span class="line">&#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span><br><span class="line"></span><br><span class="line">objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面直接有官方文档给我们的顺序</p>
<ul>
<li>1、<code>call_class_loads();</code>加载类中load方法</li>
<li>2、<code>more_categories = call_category_loads()</code>加载分类中load方法</li>
</ul>
<p><strong>Demo</strong><br>我们这里来一个测试demo</p>
<ul>
<li>父类<code>Person</code><ul>
<li>1、分类<code>Person+Run.h</code></li>
<li>2、分类<code>Person+Eat</code></li>
</ul>
</li>
<li>2、子类<ul>
<li>1、<code>Student</code></li>
<li>2、<code>Teacher</code></li>
</ul>
</li>
</ul>
<p>编译顺序<br><img src="/2018/12/21/5-2-Load和InitiaLize实现原理/Load1.png" title="Load1"></p>
<p>打印顺序<br><img src="/2018/12/21/5-2-Load和InitiaLize实现原理/Load2.png" title="Load2"></p>
<ul>
<li>1、先编译<code>Teacher</code>但是最先打印<code>Person</code></li>
<li>2、分类<code>Person+Run</code>在子类<code>Student</code>之前编译，但是打印确实先打印<code>Student</code></li>
</ul>
<p>所有上面总结是十分准确的</p>
<ul>
<li>1、先调用类的+load<ul>
<li>按照编译先后顺序调用（先编译，先调用）</li>
<li>调用子类的+load之前会先调用父类的+load</li>
</ul>
</li>
<li>2、再调用分类的+load<ul>
<li>按照编译先后顺序调用（先编译，先调用）</li>
</ul>
</li>
</ul>
<p>我们是否注意到了另一个问题，为什么在有分类的时候还加载类的<code>load</code>方法，不应该是分类覆盖类吗？</p>
<p>我们在查看<code>load</code>的源码实现的时候发现，+load方法是根据方法<code>地址</code>直接调用，并不是经过<code>objc_msgSend</code>函数调用，如果使用<code>objc_msgSend</code>会出现分类覆盖类，但是<code>load</code>直接是根据<code>指针</code>找方法的，所以不会覆盖。</p>
<h3 id="Initialize实现原理"><a href="#Initialize实现原理" class="headerlink" title="Initialize实现原理"></a>Initialize实现原理</h3><blockquote>
<p>+initialize方法会在类<code>第一次接收到消息</code>时调用</p>
</blockquote>
<p><strong>调用顺序</strong></p>
<ul>
<li>先调用父类的+initialize，再调用子类的+initialize(先初始化父类，再初始化子类，每个类只会初始化1次)</li>
<li>+initialize和+load的很大区别是，+initialize是通过objc_msgSend进行调用的，所以有以下特点<ul>
<li>如果子类没有实现+initialize，会调用父类的+initialize（所以父类的+initialize可能会被调用多次）</li>
<li>如果分类实现了+initialize，就覆盖类本身的+initialize调用</li>
</ul>
</li>
</ul>
<p><strong>objc4源码解读过程</strong></p>
<p>objc-runtime-new.mm</p>
<ul>
<li>class_getInstanceMethod</li>
<li>lookUpImpOrNil</li>
<li>lookUpImpOrForward</li>
<li>_class_initialize</li>
<li>callInitialize</li>
<li>objc_msgSend(cls, SEL_initialize)</li>
</ul>
<p>我们在<code>objc-runtime-new.mm</code>文件中找到<code>class_getInstanceMethod</code>，里面就有一个主要实现方法<code>lookUpImpOrNil</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Method class_getInstanceMethod(Class cls, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">if (!cls  ||  !sel) return nil;</span><br><span class="line">#warning fixme build and search caches</span><br><span class="line">lookUpImpOrNil(cls, sel, nil, </span><br><span class="line">NO/*initialize*/, NO/*cache*/, YES/*resolver*/);</span><br><span class="line">#warning fixme build and search caches</span><br><span class="line">return _class_getMethod(cls, sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面没有什么实现我们继续点击<code>lookUpImpOrNil</code>进入实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrNil(Class cls, SEL sel, id inst, </span><br><span class="line">bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);</span><br><span class="line">if (imp == _objc_msgForward_impcache) return nil;</span><br><span class="line">else return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>里面好像还是没有我们想要的具体实现，继续点击<code>lookUpImpOrForward</code>查看实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">runtimeLock.unlockRead();</span><br><span class="line">_class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">runtimeLock.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个里面有一个<code>if</code>判断里面有一些东西，就是在没有实现<code>isInitialized</code>的时候，调用<code>_class_initialize</code>方法，我们点击进入查看相关实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">_class_initialize(supercls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callInitialize(cls);</span><br></pre></td></tr></table></figure>
<p>里面有这两个主要的函数</p>
<ul>
<li>1、第一个是判断是否存在父类，以及父类是否实现<code>initialize</code>方法，如果没有实现就去实现</li>
<li>2、去实现自己的<code>initialize</code>方法。</li>
</ul>
<p>我们在点击<code>callInitialize</code>发现具体是通过<code>objc_msgSend</code>来实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void callInitialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">asm(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Demo</strong><br>测试案例1<br>我们创建父类<code>Person</code>，然后创建子类<code>Student</code>&amp;<code>Teacher</code>，子类不实现<code>initialize</code>方法，父类实现该方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Teacher alloc];</span><br><span class="line">[Student alloc];</span><br></pre></td></tr></table></figure></p>
<img src="/2018/12/21/5-2-Load和InitiaLize实现原理/initialize.png" title="initialize">
<p>结果打印三次<code>[Person initialize]</code>方法，打印一次我们是能够想到了，因为实现过程是先看看父类有没有已经实现，如果没有实现就先实现父类的。但是另外两次是怎么来的呢。</p>
<p><code>[Student alloc]</code>的实现大概是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend([Person class], @selector(initialize));</span><br><span class="line">objc_msgSend([Student class], @selector(initialize));</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1、第一步就是实现父类的<code>initialize</code>方法</li>
<li>2、第二步，Student先查找自己元类有没有<code>initialize</code>方法，如果自己元类没有实现，就向上查找父类元类有没有<code>initialize</code>方法，如果有就执行，没有继续向上查找 </li>
</ul>
<p>测试案例2</p>
<p>我们创建父类<code>Person</code>，然后创建分类<code>Person+Eat</code>，都是实现<code>initialize</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Person alloc];</span><br></pre></td></tr></table></figure></p>
<img src="/2018/12/21/5-2-Load和InitiaLize实现原理/initialize2.png" title="initialize2">
<p>这句代码就是证明了<code>如果分类实现了+initialize，就覆盖类本身的+initialize调用</code></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>load、initialize方法的区别什么？</p>
<ul>
<li>1.调用方式<ul>
<li>1&gt; load是根据函数地址直接调用</li>
</ul>
</li>
<li>2&gt; initialize是通过objc_msgSend调用</li>
</ul>
<p>-2.调用时刻</p>
<pre><code>- 1&gt; load是runtime加载类、分类的时候调用（只会调用1次）
- 2&gt; initialize是类第一次接收到消息的时候调用，每一个类只会initialize一次（父类的initialize方法可能会被调用多次）
</code></pre><p>load、initialize的调用顺序？</p>
<p>1.load</p>
<ul>
<li><p>1&gt; 先调用类的load</p>
<ul>
<li>a) 先编译的类，优先调用load</li>
<li>b) 调用子类的load之前，会先调用父类的load</li>
</ul>
</li>
<li><p>2&gt; 再调用分类的load</p>
<ul>
<li>a) 先编译的分类，优先调用load</li>
</ul>
</li>
</ul>
<p>2.initialize</p>
<ul>
<li>1&gt; 先初始化父类</li>
<li>2&gt; 再初始化子类（可能最终调用的是父类的initialize方法）</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/21/5-1-分类的实现原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NSLegend">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/21/5-1-分类的实现原理/" itemprop="url">5.1 分类的实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-21T10:19:27+08:00">
                2018-12-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS底层/" itemprop="url" rel="index">
                    <span itemprop="name">iOS底层</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先创建一个<code>person</code>类，然后在创建<code>person</code>类的两个分类<code>Person+eat</code>&amp;<code>Person+Run</code>。<br>研究原理的思路是</p>
<ul>
<li>1、生成c++文件，查看c++文件中的实现</li>
<li>2、如果c++文件中实现介绍的不太具体就去查看<a href="https://opensource.apple.com/source/objc4/" target="_blank" rel="noopener">源码</a>实现</li>
</ul>
<p>我们使用<code>xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc Person+eat.m</code>来生成c++代码</p>
<p>我们可以找到分类都包含了哪些东西<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct _category_t &#123;</span><br><span class="line">const char *name;</span><br><span class="line">struct _class_t *cls;</span><br><span class="line">const struct _method_list_t *instance_methods;</span><br><span class="line">const struct _method_list_t *class_methods;</span><br><span class="line">const struct _protocol_list_t *protocols;</span><br><span class="line">const struct _prop_list_t *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们发现里面并没有对方法属性协议等等的具体实现过程，那么我们在去<a href="https://opensource.apple.com/source/objc4/" target="_blank" rel="noopener">源码</a>中查看一下相关实现过程。</p>
<p>源码解读顺序</p>
<ul>
<li>1、objc-os.mm（runtime初始化的代码）<ul>
<li>_objc_init</li>
<li>map_images</li>
<li>map_images_nolock</li>
</ul>
</li>
<li>2、objc-runtime-new.mm<ul>
<li>_read_images</li>
<li>remethodizeClass</li>
<li>attachCategories</li>
<li>attachLists</li>
<li>realloc、memmove、 memcpy</li>
</ul>
</li>
</ul>
<p>我们按照源码查找一路找到<code>attachCategories</code>方法，我们发现这个方法就是对分类的实现。里面第一句解释<code>Attach method lists and properties and protocols from categories to a class.</code>将方法列表、属性和协议从类别附加到类中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">static void </span><br><span class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">if (!cats) return;</span><br><span class="line">if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">bool isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">//方法数组，这是一个二维数组</span><br><span class="line">/*</span><br><span class="line">[</span><br><span class="line">[method_t,method_t],</span><br><span class="line">[method_t,method_t]</span><br><span class="line">]</span><br><span class="line">*/</span><br><span class="line">method_list_t **mlists = (method_list_t **)</span><br><span class="line">malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">//属性数组，这是一个二维数组</span><br><span class="line">property_list_t **proplists = (property_list_t **)</span><br><span class="line">malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class="line">//协议数组，这是一个二维数组</span><br><span class="line">protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class="line"></span><br><span class="line">int mcount = 0;</span><br><span class="line">int propcount = 0;</span><br><span class="line">int protocount = 0;</span><br><span class="line">int i = cats-&gt;count;</span><br><span class="line">bool fromBundle = NO;</span><br><span class="line">while (i--) &#123;</span><br><span class="line">//取出某个分类</span><br><span class="line">auto&amp; entry = cats-&gt;list[i];</span><br><span class="line">//取出分类里面的方法列表</span><br><span class="line">method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">if (mlist) &#123;</span><br><span class="line">mlists[mcount++] = mlist;</span><br><span class="line">fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">property_list_t *proplist = </span><br><span class="line">entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">if (proplist) &#123;</span><br><span class="line">proplists[propcount++] = proplist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol_list_t *protolist = entry.cat-&gt;protocols;</span><br><span class="line">if (protolist) &#123;</span><br><span class="line">protolists[protocount++] = protolist;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//得到对象里面的数据</span><br><span class="line">auto rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">//将所有分类的对象方法，附加到类对象的方法列表中</span><br><span class="line">rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">free(mlists);</span><br><span class="line">if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</span><br><span class="line">//将所有分类的属性，附加到类对象的属性列表中</span><br><span class="line">rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">free(proplists);</span><br><span class="line">//将所有分类的协议，附加到类对象的协议列表中</span><br><span class="line">rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">free(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现<code>rw-&gt;methods.attachLists(mlists, mcount);</code>方法是实现将所有分类的对象方法，附加到类对象的方法列表中，其他两个属性和协议都是调用这个方法，我们分析一个就可以了。</p>
<p>点击进入<code>attachLists</code>方法，里面有一个段实现代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (hasArray()) &#123;</span><br><span class="line">// many lists -&gt; many lists</span><br><span class="line">uint32_t oldCount = array()-&gt;count;</span><br><span class="line">uint32_t newCount = oldCount + addedCount;</span><br><span class="line">setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">array()-&gt;count = newCount;</span><br><span class="line">//array()-&gt;list 原来的方法列表</span><br><span class="line">memmove(array()-&gt;lists + addedCount, array()-&gt;lists, </span><br><span class="line">oldCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">//addedList 所有分类的方法列表</span><br><span class="line">memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1、扩容，把类中的方法数组和分类中的方法数组计算出来</li>
<li>2、<code>memmove</code>把类中方法放到数组的最后一位</li>
<li>3、<code>memcpy</code>把分类中的方法放到数组的前面。</li>
</ul>
<img src="/2018/12/21/5-1-分类的实现原理/分类.png" title="分类">

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/20/4-KVC/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NSLegend">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/20/4-KVC/" itemprop="url">4.KVC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-20T16:00:13+08:00">
                2018-12-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS底层/" itemprop="url" rel="index">
                    <span itemprop="name">iOS底层</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>KVC（Key-value coding）键值编码，指iOS的开发中，可以允许开发者通过Key名直接访问对象的属性，或者给对象的属性赋值而不需要调用明确的存取方法。</p>
<h3 id="1、KVC中常见方法"><a href="#1、KVC中常见方法" class="headerlink" title="1、KVC中常见方法"></a>1、KVC中常见方法</h3><p>我们随便点击进入<code>setValue:forKey</code>方法，我们可以发现里面的方法基本上都是基于<code>NSObject</code>的<code>NSKeyValueCoding</code>分类写的，所以对于所有继承了NSObject的类型，也就是几乎所有的Objective-C对象都能使用KVC(一些纯Swift类和结构体是不支持KVC的)，下面是KVC最为重要的四个方法<br><img src="/2018/12/20/4-KVC/KVC1.png" title="KVC1"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForKey:(NSString *)key;                          //直接通过Key来取值</span><br><span class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;          //通过Key来设值</span><br><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath;                  //通过KeyPath来取值</span><br><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;  //通过KeyPath来设值</span><br></pre></td></tr></table></figure></p>
<p><code>NSKeyValueCoding</code>类别中还有其他的一些方法，这些方法在碰到特殊情况或者有特殊需求还是会用到的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)accessInstanceVariablesDirectly;</span><br><span class="line">//默认返回YES，表示如果没有找到Set&lt;Key&gt;方法的话，会按照_key，_iskey，key，iskey的顺序搜索成员，设置成NO就不这样搜索</span><br><span class="line"></span><br><span class="line">- (BOOL)validateValue:(inout id __nullable * __nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;</span><br><span class="line">//KVC提供属性值正确性�验证的API，它可以用来检查set的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。</span><br><span class="line"></span><br><span class="line">- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;</span><br><span class="line">//这是集合操作的API，里面还有一系列这样的API，如果属性是一个NSMutableArray，那么可以用这个方法来返回。</span><br><span class="line"></span><br><span class="line">- (nullable id)valueForUndefinedKey:(NSString *)key;</span><br><span class="line">//如果Key不存在，且没有KVC无法搜索到任何和Key有关的字段或者属性，则会调用这个方法，默认是抛出异常。</span><br><span class="line"></span><br><span class="line">- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;</span><br><span class="line">//和上一个方法一样，但这个方法是设值。</span><br><span class="line"></span><br><span class="line">- (void)setNilValueForKey:(NSString *)key;</span><br><span class="line">//如果你在SetValue方法时面给Value传nil，则会调用这个方法</span><br><span class="line"></span><br><span class="line">- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;</span><br><span class="line">//输入一组key,返回该组key对应的Value，再转成字典返回，用于将Model转到字典。</span><br></pre></td></tr></table></figure></p>
<h3 id="2、KVC的内部实现机制"><a href="#2、KVC的内部实现机制" class="headerlink" title="2、KVC的内部实现机制"></a>2、KVC的内部实现机制</h3><h4 id="KVO的setValue-forKey原理"><a href="#KVO的setValue-forKey原理" class="headerlink" title="KVO的setValue:forKey原理"></a>KVO的<code>setValue:forKey</code>原理</h4><p>我们先来一张图片可以直接明了的看清楚实现原理<br><img src="/2018/12/20/4-KVC/KVC2.png" title="KVC2"></p>
<ul>
<li>1、按照<code>setKey</code>，<code>_setKey</code>的顺序查找<code>成员方法</code>，如果找到方法，传递参数，调用方法</li>
<li>2、如果没有找到，查看<code>accessInstanceVariablesDirectly</code>的返回值（<code>accessInstanceVariablesDirectly</code>的返回值默认是<code>YES</code>），<ul>
<li>返回值为YES，按照<code>_Key,_isKey,Key,isKey</code>的顺序查找<code>成员变量</code>，如果找到，直接赋值，如果没有找到，调用<code>setValue:forUndefinedKey:</code>，抛出异常</li>
<li>返回NO，直接调用<code>setValue:forUndefinedKey:</code>，抛出异常</li>
</ul>
</li>
</ul>
<h4 id="KVO的ValueforKey原理"><a href="#KVO的ValueforKey原理" class="headerlink" title="KVO的ValueforKey原理"></a>KVO的<code>ValueforKey</code>原理</h4><img src="/2018/12/20/4-KVC/KVC3.png" title="KVC3">
<ul>
<li>1、按照<code>getKey,key,isKey,_key</code>的顺序查找<code>成员方法</code>，如果找到直接调用<code>取值</code></li>
<li>2、如果没有找到，查看<code>accessInstanceVariablesDirectly</code>的返回值</li>
<li>返回值为YES，按照<code>_Key,_isKey,Key,isKey</code>的顺序查找<code>成员变量</code>，如果找到，直接<code>取值</code>，如果没有找到，调用<code>setValue:forUndefinedKey:</code>，抛出异常</li>
<li>返回NO，直接调用<code>setValue:forUndefinedKey:</code>，抛出异常</li>
</ul>
<h3 id="3、KVC的使用"><a href="#3、KVC的使用" class="headerlink" title="3、KVC的使用"></a>3、KVC的使用</h3><h4 id="KVC基础使用"><a href="#KVC基础使用" class="headerlink" title="KVC基础使用"></a>KVC基础使用</h4><p>假设我们有一个<code>Person</code>类，里面有一个<code>age</code>属性，我们给<code>age</code>赋值和取值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [[Person alloc]init];</span><br><span class="line">//赋值</span><br><span class="line">[p setValue:@10 forKey:@&quot;age&quot;];</span><br><span class="line">//取值</span><br><span class="line">[p valueForKey:@&quot;age&quot;]</span><br></pre></td></tr></table></figure>
<p>这也是最简单的使用方法了，也是我们平时项目中最常使用的方法了</p>
<h4 id="KVC中使用keyPath"><a href="#KVC中使用keyPath" class="headerlink" title="KVC中使用keyPath"></a>KVC中使用keyPath</h4><p>但是当<code>Person</code>类里面有一个<code>student</code>类，里面有一个<code>height</code>属性，我们怎么赋值<code>height</code>属性呢，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic,assign) int age;</span><br><span class="line"></span><br><span class="line">@property (nonatomic,strong) Student *stu;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>我们能否这样写呢<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [[Person alloc]init];</span><br><span class="line">//赋值</span><br><span class="line">[p setValue:@10 forKey:@&quot;stu.height&quot;];</span><br><span class="line">//取值</span><br><span class="line">[p valueForKey:@&quot;stu.height&quot;]</span><br></pre></td></tr></table></figure></p>
<p>我们运行程序打印结果<br><img src="/2018/12/20/4-KVC/KVC4.png" title="KVC4"></p>
<p>打印结果是<code>this class is not key value coding-compliant for the key stu.height.</code>,所以这个方法是不可以的，但是iOS为我们提供了另一个方法<code>KeyPath</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [[Person alloc]init];</span><br><span class="line">p.stu = [[Student alloc]init];</span><br><span class="line">[p setValue:@180 forKeyPath:@&quot;stu.height&quot;];</span><br><span class="line">NSLog(@&quot;valueForKey:%@&quot;,[p valueForKeyPath:@&quot;stu.height&quot;]);</span><br><span class="line">NSLog(@&quot;stu.height:%f&quot;,p.stu.height);</span><br></pre></td></tr></table></figure></p>
<p>打印结果<br><img src="/2018/12/20/4-KVC/KVC5.png" title="KVC5"></p>
<p><code>keyPath</code>除了对当前对象的属性进行赋值外，还可以对其更“深层”的对象进行赋值。KVC进行多级访问时，直接类似于属性调用一样用点语法进行访问即可。</p>
<h4 id="KVC之集合属性"><a href="#KVC之集合属性" class="headerlink" title="KVC之集合属性"></a>KVC之集合属性</h4><p>如果我们想要修改集合类型，我们该怎么办呢，不要着急，系统还是很友好的给我们提供了一些方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;</span><br><span class="line">- (NSMutableArray *)mutableArrayValueForKeyPath:(NSString *)keyPath</span><br><span class="line"></span><br><span class="line">- (NSMutableSet *)mutableSetValueForKey:(NSString *)key</span><br><span class="line">- (NSMutableSet *)mutableSetValueForKeyPath:(NSString *)keyPath</span><br><span class="line"></span><br><span class="line">- (NSMutableOrderedSet *)mutableOrderedSetValueForKey:(NSString *)key </span><br><span class="line">- (NSMutableOrderedSet *)mutableOrderedSetValueForKeyPath:(NSString *)keyPath</span><br></pre></td></tr></table></figure></p>
<p>简单使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [[Person alloc]init];</span><br><span class="line">[[p mutableArrayValueForKey:@&quot;list&quot;] addObject:@&quot;test&quot;];</span><br><span class="line">NSLog(@&quot;mutableArrayValueForKey:%@&quot;,[p valueForKeyPath:@&quot;list&quot;]);</span><br><span class="line">NSLog(@&quot;%@&quot;,p.list);</span><br></pre></td></tr></table></figure></p>
<p>关于<code>mutableArrayValueForKey:</code>的适用场景，网上一般说是在<code>KVO</code>中，因为<code>KVO的本质是系统监测到某个属性的内存地址或常量改变</code>时会添加上<code>- (void)willChangeValueForKey:(NSString *)key</code>和<code>- (void)didChangeValueForKey:(NSString *)key</code>方法来发送通知，但是如果直接改数组的话，内存地址并没有改变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">_p = [[Person alloc]init];</span><br><span class="line">[_p addObserver:self forKeyPath:@&quot;list&quot; options:options context:nil];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">//    [_p.list addObject:@(arc4random()%255)];</span><br><span class="line">//    NSLog(@&quot;打印内存地址：%x&quot;,self.p.list);</span><br><span class="line">//    NSLog(@&quot;打印内容:%@&quot;,self.p.list);</span><br><span class="line"></span><br><span class="line">[[self.p mutableArrayValueForKey:@&quot;list&quot;] addObject:@(arc4random()%255)];</span><br><span class="line">NSLog(@&quot;打印内存地址：%x&quot;,self.p.list);</span><br><span class="line">NSLog(@&quot;打印内容:%@&quot;,self.p.list);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">NSLog(@&quot;%@&quot;,change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)dealloc&#123;</span><br><span class="line">[_p removeObserver:self forKeyPath:@&quot;list&quot;]; //一定要在dealloc里面移除观察</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们分别用<code>[_p.list addObject:@(arc4random()%255)];</code>和<code>[[self.p mutableArrayValueForKey:@&quot;list&quot;] addObject:@(arc4random()%255)];</code>两个方法修改<code>list</code>内容，我们打印可知<code>[_p.list addObject:@(arc4random()%255)];</code>方法并没有改变<code>list</code>的内存地址，而使用<code>[[self.p mutableArrayValueForKey:@&quot;list&quot;] addObject:@(arc4random()%255)];</code>  ， <code>list</code>的内存地址改变了。</p>
<h4 id="KVC之字典属性"><a href="#KVC之字典属性" class="headerlink" title="KVC之字典属性"></a>KVC之字典属性</h4><p>KVC里面还有两个关于NSDictionary的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;</span><br><span class="line">- (void)setValuesForKeysWithDictionary:(NSDictionary&lt;NSString *, id&gt; *)keyedValues;</span><br></pre></td></tr></table></figure></p>
<p><code>dictionaryWithValuesForKeys:</code>是指输入一组key，返回这组key对应的属性，再组成一个字典<br><code>setValuesForKeysWithDictionary</code>是用来修改dic中对应key的属性</p>
<p>这个属性最常用到的地方就是字典转模型<br>例如我们有一个<code>Student</code>类，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface Student : NSObject</span><br><span class="line">@property (nonatomic,assign) float height;</span><br><span class="line">@property (nonatomic,assign) int age;</span><br><span class="line">@property (nonatomic,strong) NSString *name;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>我们正常是怎么赋值呢<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student *stu = [[Student alloc]init];</span><br><span class="line">stu.age = 10;</span><br><span class="line">stu.name = @&quot;jack&quot;;</span><br><span class="line">stu.height = 180;</span><br></pre></td></tr></table></figure></p>
<p>如果里面有100个属性呢，我们就需要写100遍<br>如果使用<code>setValuesForKeysWithDictionary</code>方法呢<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student *stu = [[Student alloc]init];</span><br><span class="line">//在进行网络请求的时候dic不需要我们手写，是后台返回的</span><br><span class="line">NSDictionary *dic = @&#123;@&quot;name&quot;:@&quot;jack&quot;,@&quot;height&quot;:@180,@&quot;age&quot;:@10&#125;;</span><br><span class="line">[stu setValuesForKeysWithDictionary:dic];</span><br></pre></td></tr></table></figure></p>
<p>这样是不是简单了好多。</p>
<h3 id="4、KVC异常处理"><a href="#4、KVC异常处理" class="headerlink" title="4、KVC异常处理"></a>4、KVC异常处理</h3><p>当根据KVC搜索规则，没有搜索到对应的key或者keyPath，则会调用对应的异常方法。异常方法的默认实现，在异常发生时会抛出一个<code>NSUndefinedKeyException</code>的异常，并且应用程序<code>Crash</code>。我们可以重写下面两个方法，根据业务需求合理的处理KVC导致的异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForUndefinedKey:(NSString *)key;</span><br><span class="line">- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;</span><br><span class="line">- (void)setNilValueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure></p>
<p>其中重写这两个方法，在<code>key</code>值不存在的时候，会走下面方法，而不会异常抛出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForUndefinedKey:(NSString *)key;</span><br><span class="line">- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;</span><br></pre></td></tr></table></figure></p>
<p>重写这个方法，当value值为nil的时候，会走下面方法，而不会异常抛出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setNilValueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure></p>
<h3 id="5、KVC的正确性验证"><a href="#5、KVC的正确性验证" class="headerlink" title="5、KVC的正确性验证"></a>5、KVC的正确性验证</h3><p>在调用KVC时可以先进行验证，验证通过下面两个方法进行，支持key和keyPath两种方式。验证方法默认实现返回YES，可以通过重写对应的方法修改验证逻辑。</p>
<p>验证方法需要我们手动调用，并不会在进行KVC的过程中自动调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;</span><br><span class="line">- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKeyPath:(NSString *)inKeyPath error:(out NSError **)outError;</span><br></pre></td></tr></table></figure></p>
<p> 在validateValue方法的内部实现中，如果传入的value或key有问题，可以通过返回NO来表示错误，并设置NSError对象。</p>
<p> 因为还需要我们手动调用校验，感觉用处不太大。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/20/3-KVO/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NSLegend">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/20/3-KVO/" itemprop="url">3.KVO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-20T15:25:59+08:00">
                2018-12-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS底层/" itemprop="url" rel="index">
                    <span itemprop="name">iOS底层</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>KVO（key value observing）</code>键值监听是我们在开发中常使用的用于监听特定对象属性值变化的方法，常用于监听数据模型的变化</p>
<p>KVO是为了监听一个对象的某个属性值是否发生变化。在属性值发生变化的时候，肯定会调用其setter方法。所以<code>KVO的本质就是监听对象有没有调用被监听属性对应的setter方法</code></p>
<p>在学习实现原理之前先了解一下KVO常用的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">注册监听器</span><br><span class="line">监听器对象为observer，被监听对象为消息的发送者即方法的调用者在回调函数中会被回传</span><br><span class="line">监听的属性路径为keyPath支持点语法的嵌套</span><br><span class="line">监听类型为options支持按位或来监听多个事件类型</span><br><span class="line">监听上下文context主要用于在多个监听器对象监听相同keyPath时进行区分</span><br><span class="line">添加监听器只会保留监听器对象的地址，不会增加引用，也不会在对象释放后置空，因此需要自己持有监听对象的强引用，该参数也会在回调函数中回传</span><br><span class="line">*/</span><br><span class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">删除监听器</span><br><span class="line">监听器对象为observer，被监听对象为消息的发送者即方法的调用者，应与addObserver方法匹配</span><br><span class="line">监听的属性路径为keyPath，应与addObserver方法的keyPath匹配</span><br><span class="line">监听上下文context，应与addObserver方法的context匹配</span><br><span class="line">*/</span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context API_AVAILABLE(macos(10.7), ios(5.0), watchos(2.0), tvos(9.0));</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">与上一个方法相同，只是少了context参数</span><br><span class="line">推荐使用上一个方法，该方法由于没有传递context可能会产生异常结果</span><br><span class="line">*/</span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">监听器对象的监听回调方法</span><br><span class="line">keyPath即为监听的属性路径</span><br><span class="line">object为被监听的对象</span><br><span class="line">change保存被监听的值产生的变化</span><br><span class="line">context为监听上下文，由add方法回传</span><br><span class="line">*/</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context;</span><br></pre></td></tr></table></figure>
<h3 id="KVO简单实现"><a href="#KVO简单实现" class="headerlink" title="KVO简单实现"></a>KVO简单实现</h3><p>我们创建一个<code>person</code>对象，然后在里面添加一个<code>age</code>属性，我们就来观察一下<code>age</code>属性<br><strong>person对象</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property (nonatomic,assign) NSInteger age;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>简单实现</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic,strong) Person *p1;</span><br><span class="line">@property (nonatomic,strong) Person *p2;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line"></span><br><span class="line">self.p1 = [[Person alloc]init];</span><br><span class="line">self.p2 = [[Person alloc]init];</span><br><span class="line">self.p1.age = 10;</span><br><span class="line">self.p2.age = 20;</span><br><span class="line"></span><br><span class="line">// 给person1对象添加KVO监听</span><br><span class="line">NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">[self.p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:@&quot;123&quot;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">self.p1.age = arc4random()%100;</span><br><span class="line">self.p2.age = arc4random()%100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">[self.p1 removeObserver:self forKeyPath:@&quot;age&quot;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 当监听对象的属性值发生改变时，就会调用</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">NSLog(@&quot;监听到%@的%@属性值改变了 - %@ - %@&quot;, object, keyPath, change, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码就是一个<code>KVO</code>的简单实现，但是我们有没有想过他的内部到底是怎样实现的呢，今天我们就来探究一下<code>KVO</code>的内部实现原理</p>
<h3 id="KVO的内部实现"><a href="#KVO的内部实现" class="headerlink" title="KVO的内部实现"></a>KVO的内部实现</h3><p>探究一个对象底层实现最简单的办法就行打印一些对象信息，看看有什么改变</p>
<p>我们在给<code>person1</code>添加监听之前分别打印<code>p1,p2</code>的类信息<br>代码实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;person1添加KVO监听之前 - %@ %@&quot;,</span><br><span class="line">object_getClass(self.p1),</span><br><span class="line">object_getClass(self.p2));</span><br><span class="line">// 给person1对象添加KVO监听</span><br><span class="line">NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">[self.p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:@&quot;123&quot;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSLog(@&quot;person1添加KVO监听之后 - %@ %@&quot;,</span><br><span class="line">object_getClass(self.p1),</span><br><span class="line">object_getClass(self.p2));</span><br></pre></td></tr></table></figure></p>
<p>打印结果<br><img src="/2018/12/20/3-KVO/KVO1.png" title="KVO1"></p>
<p>我们根据结果看到，在添加KVO观察者之后<code>p1</code>的类对象由<code>Person</code>变成了<code>NSKVONotifying_Person</code>，虽然<code>p1</code>的类对象变成了<code>NSKVONotifying_Person</code>，但是我们在调用的时候感觉我们的<code>p1</code>的类对象还是<code>Person</code>，所以，我们可以猜测<code>KVO</code>会在运行时动态创建一个新类，将对象的<code>isa</code>指向新创建的类，<code>新类是原类的子类</code>，命名规则是<code>NSKVONotifying_xxx</code>的格式。KVO为了使其更像之前的类，还会将对象的<code>class实例方法重写</code>，使其更像原类</p>
<p> <strong>查看P1内部方法是否改变</strong></p>
<p>我们在发现<code>p1</code>的类对象由<code>Person</code>变成了<code>NSKVONotifying_Person</code>，那我们也随便打印一下<code>Person</code>和<code>NSKVONotifying_Person</code>内部方法都变成了什么</p>
<p>打印一下方法名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)printMethodNamesOfClass:(Class)cls</span><br><span class="line">&#123;</span><br><span class="line">unsigned int count;</span><br><span class="line">// 获得方法数组</span><br><span class="line">Method *methodList = class_copyMethodList(cls, &amp;count);</span><br><span class="line"></span><br><span class="line">// 存储方法名</span><br><span class="line">NSMutableString *methodNames = [NSMutableString string];</span><br><span class="line"></span><br><span class="line">// 遍历所有的方法</span><br><span class="line">for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">// 获得方法</span><br><span class="line">Method method = methodList[i];</span><br><span class="line">// 获得方法名</span><br><span class="line">NSString *methodName = NSStringFromSelector(method_getName(method));</span><br><span class="line">// 拼接方法名</span><br><span class="line">[methodNames appendString:methodName];</span><br><span class="line">[methodNames appendString:@&quot;, &quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放</span><br><span class="line">free(methodList);</span><br><span class="line"></span><br><span class="line">// 打印方法名</span><br><span class="line">NSLog(@&quot;%@ %@&quot;, cls, methodNames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们分别在KVO监听前后在分别打印一下<code>p1</code>的类对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;person1添加KVO监听之前的内部方法===&quot;);</span><br><span class="line">[self printMethodNamesOfClass:object_getClass(self.p1)];</span><br><span class="line">// 给person1对象添加KVO监听</span><br><span class="line">NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">[self.p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:@&quot;123&quot;];</span><br><span class="line">NSLog(@&quot;person1添加KVO监听之后的内部方法===&quot;);</span><br><span class="line">[self printMethodNamesOfClass:object_getClass(self.p1)];</span><br></pre></td></tr></table></figure></p>
<p>打印结果<br><img src="/2018/12/20/3-KVO/KVO2.png" title="KVO2"></p>
<p>我们在来打印一些KVO监听前后<code>setAge</code>方法发生了什么改变，因为值得改变肯定是因为<code>set</code>方法导致的，所以我们打印一下<code>setAge</code>方法。<code>methodForSelector</code>可以打印方法地址，我们分别在KVO监听前后打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;person1添加KVO监听之前 - %p %p&quot;,</span><br><span class="line">[self.p1 methodForSelector:@selector(setAge:)],</span><br><span class="line">[self.p2 methodForSelector:@selector(setAge:)]);</span><br><span class="line"></span><br><span class="line">// 给person1对象添加KVO监听</span><br><span class="line">NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">[self.p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:@&quot;123&quot;];</span><br><span class="line">NSLog(@&quot;person1添加KVO监听之后 - %p %p&quot;,</span><br><span class="line">[self.p1 methodForSelector:@selector(setAge:)],</span><br><span class="line">[self.p2 methodForSelector:@selector(setAge:)]);</span><br></pre></td></tr></table></figure>
<p>打印结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-09-04 10:41:05.823343+0800 KVO[21971:1023542] person1添加KVO监听之前 - 0x103f18540 0x103f18540</span><br><span class="line">2018-09-04 10:41:05.823702+0800 KVO[21971:1023542] person1添加KVO监听之后 - 0x10425ebf4 0x103f18540</span><br></pre></td></tr></table></figure></p>
<p>我们可以利用lldb分别看一下具体的方法实现：</p>
<img src="/2018/12/20/3-KVO/KVO5.png" title="KVO5">
<p>根据以上总结，我们大概猜到在使用KVO前后对象的改变了<br><strong>未使用KVO监听的对象</strong></p>
<img src="/2018/12/20/3-KVO/KVO3.png" title="KVO3">
<p><strong>使用KVO监听的对象</strong><br><img src="/2018/12/20/3-KVO/KVO4.png" title="KVO4"></p>
<ul>
<li>1、重写class方法是为了我们调用它的时候返回跟重写继承类之前同样的内容。KVO底层交换了 NSKVONotifying_Person 的 class 方法，让其返回 Person</li>
<li>2、重写setter方法:在新的类中会重写对应的set方法，是为了在set方法中增加另外两个方法的调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)willChangeValueForKey:(NSString *)key</span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在didChangeValueForKey:方法再调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</span><br><span class="line">ofObject:(id)object</span><br><span class="line">change:(NSDictionary *)change</span><br><span class="line">context:(void *)context</span><br></pre></td></tr></table></figure></p>
<ul>
<li>3、重写dealloc方法，销毁新生成的NSKVONotifying_类。</li>
<li>4、重写_isKVOA方法，这个私有方法估计可能是用来标示该类是一个 KVO 机制声称的类。</li>
</ul>
<h3 id="NSSetLongLongValueAndNotify"><a href="#NSSetLongLongValueAndNotify" class="headerlink" title="_NSSetLongLongValueAndNotify"></a>_NSSetLongLongValueAndNotify</h3><p>在添加KVO监听方法以后<code>setAge</code>方法变成了<code>_NSSetLongLongValueAndNotify</code>,所以我们可以大概猜测动态监听方法主要就是在这里面实现的</p>
<p>我们可以在终端使用<code>nm -a /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation | grep ValueAndNotify</code>命令来查看<code>NSSet*ValueAndNotify</code>的类型<br><img src="/2018/12/20/3-KVO/KVO6.png" title="KVO6"></p>
<p>我们可以在<code>Person</code>类中重写<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>,来猜测一下<code>_NSSetLongLongValueAndNotify</code>的内部实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)setAge:(NSInteger)age&#123;</span><br><span class="line">_age = age;</span><br><span class="line">NSLog(@&quot;调用set方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)willChangeValueForKey:(NSString *)key&#123;</span><br><span class="line">[super willChangeValueForKey:key];</span><br><span class="line">NSLog(@&quot;willChangeValueForKey&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key&#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didChangeValueForKey - begin&quot;);</span><br><span class="line"></span><br><span class="line">[super didChangeValueForKey:key];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didChangeValueForKey - end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2018/12/20/3-KVO/KVO7.png" title="KVO7">
<p>根据打印结果我们可以推断<code>_NSSetLongLongValueAndNotify</code>内部实现为</p>
<ul>
<li>1、调用<code>willChangeValueForKey</code>方法</li>
<li>2、调用<code>setAge</code>方法</li>
<li>3、调用’didChangeValueForKey’方法</li>
<li>4、’didChangeValueForKey’方法内部调用<code>oberser</code>的<code>observeValueForKeyPath:ofObject:change:context:</code>方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 伪代码</span><br><span class="line">void _NSSetIntValueAndNotify()</span><br><span class="line">&#123;</span><br><span class="line">[self willChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">[super setAge:age];</span><br><span class="line">[self didChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">// 通知监听器，某某属性值发生了改变</span><br><span class="line">[oberser observeValueForKeyPath:key ofObject:self change:nil context:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p><strong>1、iOS用什么方式实现对一个对象的KVO（KVO的本质是什么？）</strong></p>
<ul>
<li>1、利用RuntimeAPI动态生成一个子类<code>NSKVONotifying_XXX</code>,并且让instance对象的isa指向这个全新的子类<code>NSKVONotifying_XXX</code></li>
<li>2、当修改对象的属性时，会在子类<code>NSKVONotifying_XXX</code>调用Foundation的<code>_NSSetXXXValueAndNotify</code>函数</li>
<li>3、在<code>_NSSetXXXValueAndNotify</code>函数中一次调用<ul>
<li>1、willChangeValueForKey</li>
<li>2、父类原来的setter</li>
<li>3、didChangeValueForKey，didChangeValueForKey：内部会出发监听器（Observer）的监听方法( observeValueForKeyPath:ofObject:change:context:）</li>
</ul>
</li>
</ul>
<p><strong>2、如何手动触发KVO方法</strong><br>手动调用<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>方法</p>
<p>键值观察通知依赖于 NSObject 的两个方法: <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey</code>。在一个被观察属性发生改变之前， <code>willChangeValueForKey:</code> 一定会被调用，这就<br>会记录旧的值。而当改变发生后， <code>didChangeValueForKey</code> 会被调用，继而 <code>observeValueForKey:ofObject:change:context:</code>也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了</p>
<p>有人可能会问只调用<code>didChangeValueForKey</code>方法可以触发KVO方法，其实是不能的，因为<code>willChangeValueForKey:</code> 记录旧的值，如果不记录旧的值，那就没有改变一说了</p>
<p><strong>3、直接修改成员变量会触发KVO吗</strong><br>不会触发KVO，因为<code>KVO的本质就是监听对象有没有调用被监听属性对应的setter方法</code>，直接修改成员变量，是在内存中修改的，不走<code>set</code>方法</p>
<p><strong>4、不移除KVO监听，会发生什么</strong></p>
<ul>
<li>不移除会造成内存泄漏</li>
<li>但是多次重复移除会崩溃。系统为了实现KVO，为NSObject添加了一个名为NSKeyValueObserverRegistration的Category，KVO的add和remove的实现都在里面。在移除的时候，系统会判断当前KVO的key是否已经被移除，如果已经被移除，则主动抛出一个NSException的异常</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/20/2-OC对象的分类/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NSLegend">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/20/2-OC对象的分类/" itemprop="url">2.OC对象的分类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-20T14:22:57+08:00">
                2018-12-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS底层/" itemprop="url" rel="index">
                    <span itemprop="name">iOS底层</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>OC对象主要可以分为3种</p>
<ul>
<li>1、instance对象（实例对象）：instance实例对象就是通过alloc出来的对象，每次调用alloc都会产生新的instance对象</li>
<li>2、class对象（类对象）：每个类的内存中有且只有一个类对象</li>
<li>3、meta-class对象（元类对象）：每个类的内存中有且只有一个元类对象</li>
</ul>
<p>实例对象的存储信息</p>
<ul>
<li>isa指针</li>
<li>其他成员变量</li>
</ul>
<p>类对象的存储信息<br>-isa指针</p>
<ul>
<li>superClass指针</li>
<li>类的属性信息（@property），类的对象方法信息（method），类的协议信息（protocol），类的成员变量信息（ivar）</li>
</ul>
<p>元类的存储信息</p>
<ul>
<li>isa指针</li>
<li>superClass指针</li>
<li>类的属性信息（@property），类的对象方法信息（method），类的协议信息（protocol），类的成员变量信息（ivar）</li>
</ul>
<p><code>元类和类的存储结构是一样的，但是用途不一样</code><br><img src="/2018/12/20/2-OC对象的分类/OC对象的分类1.png" title="OOC对象的分类1"></p>
<ul>
<li>instance的isa指向class，当调用<code>对象方法</code>时，通过instance的isa找到class，最后找到对象方法的实现进行调用</li>
<li>class的isa指向meta-class，当调用<code>类方法</code>时，通过class当isa找到meta-class，最后找到<code>类方法</code></li>
</ul>
<h3 id="总览图"><a href="#总览图" class="headerlink" title="总览图"></a>总览图</h3><img src="/2018/12/20/2-OC对象的分类/OC对象的分类2.png" title="OOC对象的分类2">
<ul>
<li>1、instance的isa指向class</li>
<li>2、class的isa指向meta-class</li>
<li>3、meta-class的isa指向基类的meta-class</li>
<li>4、class的superclass指向父类的class，如果没有父类，superclass指向nil</li>
<li>5、meta-class的superclass指向父类的meta-class，基类的meta-class的superclass指向基类的class</li>
<li>6、instance的调用轨迹：isa找class，方法不存在，就通过superclass找父类</li>
<li>7、class调用类方法的轨迹：isa找到meta-class，方法不存在，就通过superclass找父类</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/20/1-一个NSObject对象占用多少内存/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NSLegend">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/20/1-一个NSObject对象占用多少内存/" itemprop="url">1.一个NSObject对象占用多少内存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-20T09:32:47+08:00">
                2018-12-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS底层/" itemprop="url" rel="index">
                    <span itemprop="name">iOS底层</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们平时所编写的Object-C代码，底层实现都是C/C++代码，</p>
<img src="/2018/12/20/1-一个NSObject对象占用多少内存/Object-C代码底层实现.png" title="Object-C代码底层实现">
<p> 所有OC的面向对象都是基于C/C++的数据结构实现的<br> <code>思考:OC对象主要是基于C/C++的什么数据结构实现的呢？？？</code></p>
<p> 想要了解OC对象主要是基于C/C++的什么数据结构实现的，我们首先要做的就是将Object-C代码转化为C/C++代码，这样我们才能清楚的看清是怎么实现的</p>
<p> 然后我们打开终端，命令行cd到文件目录，然后输入：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br></pre></td></tr></table></figure></p>
<p> 命令可以将main.m编译成C++的代码，改成不同的文件名，就会生成不同的c++代码<br> 这时就生成了main.cpp这个c++文件，打开文件代码查看main.cpp最底下的main函数</p>
<p> 但是不同平台支持的代码肯定是不一样的，像平台有Windows、mac、iOS<br>，架构有模拟器（i386）、32bit（armv7）、64bit（arm64），我们使用iOS，它的架构现在基本上都是64bit（arm64）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc OC源文件  -o  输出的CPP文件</span><br><span class="line">如果需要链接其他框架，使用-framework参数。比如-framework UIKit</span><br></pre></td></tr></table></figure>
<p>在终端输入命令以后，我们会生成一个main.cpp文件，打开main.cpp文件，我们把main.cpp拉到最下面，会看到这样一段代码<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> int main(int argc, const char * argv[]) &#123;</span><br><span class="line"> /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"> &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一段代码就是我们OC代码中的main函数的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p>
<p>这时我们在main函数写入这一段代码，然后点进去，查看代码实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSObject *obj = [[NSObject alloc]init];</span><br></pre></td></tr></table></figure></p>
<p>点击NSObject进入内部，可以看到NSObject底层实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct NSObject &#123;</span><br><span class="line">Class isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 我们用NSObject_IMPL查找在c++文件中具体的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">Class isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 我们再一次执行命令<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc mian.m</span><br></pre></td></tr></table></figure></p>
<p> 生成的C++代码为<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> int main(int argc, const char * argv[]) &#123;</span><br><span class="line"> /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">     NSObject *obj = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</span><br><span class="line">     </span><br><span class="line"> &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有两个方法可以打印内存大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">#import &lt;malloc/malloc.h&gt;</span><br><span class="line">//获取NSObject实例对象的成员变量所占用的大小</span><br><span class="line">NSLog(@&quot;%zd&quot;,class_getInstanceSize([NSObject class]));</span><br><span class="line"> </span><br><span class="line">//获得obj指针所指向内存的大小</span><br><span class="line">NSLog(@&quot;%zd&quot;,malloc((__bridge const void*)obj)));</span><br></pre></td></tr></table></figure></p>
<p>打印结果<br><img src="/2018/12/20/1-一个NSObject对象占用多少内存/NSObject对象内存.png" title="NSObject对象内存"></p>
<h3 id="一个OC对象在内存中是怎样布局的呢"><a href="#一个OC对象在内存中是怎样布局的呢" class="headerlink" title="一个OC对象在内存中是怎样布局的呢"></a>一个OC对象在内存中是怎样布局的呢</h3><p>我们在c++文件中找到NSObject的实现<br>OC代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct NSObject &#123;</span><br><span class="line">Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>c++代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们知道一个指针式8个字节，但是NSObject对象打印16个字节，他们是怎么布局的呢</p>
<img src="/2018/12/20/1-一个NSObject对象占用多少内存/NSObject对象内存地址.png" title="NSObject对象内存地址">
<p>我们可以根据内存地址实时查看内存分配情况Debug -&gt; Debug Workfllow -&gt; View Memory （Shift + Command + M）</p>
<img src="/2018/12/20/1-一个NSObject对象占用多少内存/查看内存数据.png" title="查看内存数据">
<img src="/2018/12/20/1-一个NSObject对象占用多少内存/查看内存数据1.png" title="查看内存数据1">
<img src="/2018/12/20/1-一个NSObject对象占用多少内存/查看内存数据2.png" title="查看内存数据2">
<p>我们也可以直接使用<code>LLDB命令</code>来查看内存地址<br><strong>常用LLDB命令</strong></p>
<ul>
<li>print、p：打印</li>
<li>po:打印对象</li>
<li>读取内存<ul>
<li>memory read/数量格式字节数 内存地址</li>
<li>x/（格式：x是16进制，f是浮点，d是10进制；字节大小：byte 1字节，h：half word 2字节，w：word 4字节，g：giant word 8字节）</li>
</ul>
</li>
<li>修改内存中的值（memory write 内存地址 数值memory write 0x0000010 10）</li>
</ul>
<p><strong>问题1</strong>：假设我创建一个<code>Student</code>类，里面有<code>age</code>，<code>number</code>两个属性，那么它的内存是多大呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student *stu = [[Student alloc]init];</span><br><span class="line">stu-&gt;_number = 4;</span><br><span class="line">stu-&gt;_age = 5;</span><br></pre></td></tr></table></figure></p>
<p>我们先执行命令，查看一下c++源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Student_IMPL &#123;</span><br><span class="line">struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">int _number;</span><br><span class="line">int _age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在知道结果之前大概猜猜内存是多大呢？16、24、32…</p>
<p>答案是16个字节。</p>
<img src="/2018/12/20/1-一个NSObject对象占用多少内存/Student内存打印.png" title="Student内存打印">
<p>我们用<code>LLDB命令</code>打印一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a9 11 00 00 01 80 1d 00 04 00 00 00 05 00 00 00</span><br></pre></td></tr></table></figure></p>
<p> 为什么会是<code>04 00 00 00</code>和<code>05 00 00 00</code>呢，而不是<code>00 00 00 04</code>和<code>00 00 00 o5</code>,这个就要考虑<a href="https://baike.baidu.com/item/大小端模式/6750542?fromtitle=大端小端&amp;fromid=15925891&amp;fr=aladdin" target="_blank" rel="noopener">大端小端</a></p>
<p>但是为什么会是16个字节呢？因为int类型占用4个字节，两个int类型8个字节，一个isa占8个字节，因为刚刚占满16个字节，对象就没在开辟新的空间</p>
<p>如果多一个height会占用几个字节呢？</p>
<img src="/2018/12/20/1-一个NSObject对象占用多少内存/Student内存打印2.png" title="Student内存打印2">
<p>答案是占用32个字节。</p>
<p>其实这又要提到一个新的知识点了<code>内存对齐</code>,我们知道OC对象就是C++结构体，<code>而结构体的大小必须是最大成员大小的倍数</code>，当在多了一个<code>height</code>以后，内存不够用了，然后就需要扩展了。</p>
<p><strong>如果是这样呢，占用内存是多少</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject&#123;</span><br><span class="line">@public</span><br><span class="line">int _number;</span><br><span class="line">int _age;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Student : Person&#123;</span><br><span class="line">@public</span><br><span class="line">int _height;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Student</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p><code>Student</code>继承自<code>Person</code></p>
<img src="/2018/12/20/1-一个NSObject对象占用多少内存/Student内存打印2.png" title="Student内存打印">
<p>我们生成C++代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Student_IMPL &#123;</span><br><span class="line">struct Person_IMPL Person_IVARS;</span><br><span class="line">int _height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Person_IMPL &#123;</span><br><span class="line">struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">int _number;</span><br><span class="line">int _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>整理一下就是这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Student_IMPL &#123;</span><br><span class="line">Class isa;</span><br><span class="line">int _number;</span><br><span class="line">int _age;</span><br><span class="line">int _height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/缘分/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NSLegend">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/缘分/" itemprop="url">缘分</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-11T10:05:25+08:00">
                2018-12-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/心灵鸡汤/" itemprop="url" rel="index">
                    <span itemprop="name">心灵鸡汤</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>什么是缘分？<br>人与人之间的相遇与相知，既是偶然，也是必然。这种看不见的命数，这种种琢磨不透的因由，理不清，剪不断，就是缘分。</p>
<p>缘分，是一种相遇。<br>在茫茫人海中，没有早一步，也没有晚一步，就这么遇到了彼此，这就是缘分。<br>人生中所有的遇见，上至父母下至路人，都是一种缘分。有的缘分很浅，只是眼神交汇最后擦肩而过；有的缘分很深，还会有长久的相知相伴；有的缘分很美好，会带给你快乐和幸福；有的缘分很痛苦，让你经受挫折和心碎。<br>爱你的人，让你温暖，伤你的人，让你成长，路过的人，丰富了你的生命。遇到什么，不是我们能决定的，但所有的缘分，都有意义。</p>
<p>缘分，也是一种重逢。<br>在漫长的人生路上，即便被时间冲淡了，被生活冲散了，最后还能重聚，这就是缘分。<br>人生最美是相遇，最难得是重逢。同窗苦读的同学，多年不见的老友，一直放在心里的恋人，再次相见，心中总是涌动着万千感慨，轻轻道一声“好久不见”。也曾有过矛盾，发生过不快，如今都被时间沉淀，留下的都是美好的回忆。<br>穿越重重人潮和漫漫时光，再见故人，是人生一大幸事。</p>
<p>缘分，更是一种珍惜。<br>一辈子，最难预料的是遇见，不知道哪一眼就是开始；最难揣测的是离别，不知道哪一面，就是后会无期。<br>我们只是尘世间一粒微小的尘埃，随缘飞舞，又随缘落去。缘分来的时候，别回避，人生苦短，错过一时也许就错过了一世。缘分走的时候，别强求，不是你的，再怎么不放手也迟早会溜走。<br>其实，所有的相遇只是个开始，唯有珍惜才能长久。不在乎的人，早晚走散，不珍惜的缘，注定没有好结果。<br>多回头看看，还有多少人一直留在身边；记得用心数数，还有几份情坚持着不离散。<br>缘分没有好坏，只有珍惜与否。最美好不过，用随缘的心态，珍惜有缘之人，过好这缘的一生。</p>
<p>摘自：<a href="https://baijiahao.baidu.com/s?id=1596416058572018324&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1596416058572018324&amp;wfr=spider&amp;for=pc</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/错误/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NSLegend">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/错误/" itemprop="url">错误</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-11T09:16:20+08:00">
                2018-12-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/心灵鸡汤/" itemprop="url" rel="index">
                    <span itemprop="name">心灵鸡汤</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>郑愁予</p>
<p>我打江南走过<br>那等在季节里的容颜如莲花的开落<br>东风不来，三月的柳絮不飞<br>你的心如小小的寂寞的城<br>恰若青石的街道向晚<br>跫音不响，三月的春帷不揭<br>你底心是小小的窗扉紧掩<br>我达达的马蹄声是美丽的错误<br>我不是归人，是个过客……<br><img src="/2018/12/11/错误/poem_mistake.JPEG" title="独依望江楼，过尽千帆皆不是"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/07/天真的预言/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NSLegend">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/07/天真的预言/" itemprop="url">天真的预言</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-07T16:42:46+08:00">
                2018-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/心灵鸡汤/" itemprop="url" rel="index">
                    <span itemprop="name">心灵鸡汤</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Auguries-of-Innocence"><a href="#Auguries-of-Innocence" class="headerlink" title="Auguries of Innocence"></a>Auguries of Innocence</h4><p>To see a world in a grain of sand<br>And a heaven in a wild flower,<br>Hold infinity in the palm of your hand<br>And eternity in an hour.</p>
<h5 id="经典译文"><a href="#经典译文" class="headerlink" title="经典译文:"></a>经典译文:</h5><h5 id="天真的预言"><a href="#天真的预言" class="headerlink" title="天真的预言"></a>天真的预言</h5><hr>
<p>一沙一世界，<br>一花一天堂。<br>双手握无限，<br>刹那是永恒。<br>一沙一世界，<br>一花一天堂，<br>一树一菩提，<br>一叶一如来。<br>天真的预言，<br>参悟千年的偈语。<br>一粒沙里见世界，<br>一朵花里见天堂，<br>手掌里盛住无限，<br>一刹那便是永劫。<br>——丰子恺</p>
<hr>
<p>一颗沙里看出一个世界，<br>一朵野花里一座天堂，<br>把无限放在你的手掌上，<br>永恒在一刹那里收藏。<br>——梁宗岱 译</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/headIcon.png" alt="NSLegend">
            
              <p class="site-author-name" itemprop="name">NSLegend</p>
              <p class="site-description motion-element" itemprop="description">Stay Hungry,Stay Foolish.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/WSGNSLog" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/ba5f297de9bc" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-heartbeat"></i>简书</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NSLegend</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
