<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Stay Hungry,Stay Foolish.">
<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="Stay Hungry,Stay Foolish.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="个人博客">
<meta name="twitter:description" content="Stay Hungry,Stay Foolish.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'NSLegend'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>个人博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Stay Hungry,Stay Foolish.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/26/9-8多线程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NSLegend">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/26/9-8多线程/" itemprop="url">9.8多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-26T10:36:21+08:00">
                2018-12-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS底层/" itemprop="url" rel="index">
                    <span itemprop="name">iOS底层</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程之间的通讯"><a href="#线程之间的通讯" class="headerlink" title="线程之间的通讯"></a>线程之间的通讯</h2><p>线程间通信的体现</p>
<ul>
<li>1、一个线程传递数据给另一个线程</li>
<li>2、在一个线程中执行完特定任务后，转到另一个线程继续执行任务</li>
</ul>
<p><strong><em>1、NSThread</em></strong><br>可以先将自己的当前线程对象注册到某个全局的对象中去，这样相互之间就可以获取对方的线程对象，然后就可以使用下面的方法进行线程间的通信了，由于主线程比较特殊，所以框架直接提供了在主线程执行的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</span><br><span class="line"></span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);</span><br></pre></td></tr></table></figure></p>
<p><strong><em>2、GCD</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//开启一个全局队列的子线程</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">//1. 开始请求数据</span><br><span class="line">//...</span><br><span class="line">// 2. 数据请求完毕</span><br><span class="line">//我们知道UI的更新必须在主线程操作，所以我们要从子线程回调到主线程</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">//我已经回到主线程更新</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/26/9-7多线程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NSLegend">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/26/9-7多线程/" itemprop="url">9.7多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-26T10:36:16+08:00">
                2018-12-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS底层/" itemprop="url" rel="index">
                    <span itemprop="name">iOS底层</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Parse源码浅析系列（一）—Parse的底层多线程处理思路：GCD高级用法"><a href="#Parse源码浅析系列（一）—Parse的底层多线程处理思路：GCD高级用法" class="headerlink" title="Parse源码浅析系列（一）—Parse的底层多线程处理思路：GCD高级用法"></a>Parse源码浅析系列（一）—Parse的底层多线程处理思路：GCD高级用法</h1><p> 【前言】从iOS7升到iOS8后，GCD 出现了一个重大的变化：在 iOS7 时，使用 GCD 的并行队列，  <code>dispatch_async</code>  最大开启的线程一直能控制在6、7条，线程数都是个位数，然而 iOS8后，最大线程数一度可以达到40条、50条。然而在文档上并没有对这一做法的目的进行介绍。</p>
<p> 笔者推测 Apple 的目的是想借此让开发者使用 <code>NSOperationQueue</code> ：GCD 中 Apple 并没有提供控制并发数量的接口，而  <code>NSOperationQueue</code>  有。GCD 没有提供暂停、恢复、取消队列任务的接口，而  <code>NSOperationQueue</code>  有，如果想让 GCD 支持 <code>NSOperationQueue</code> 原生就支持的功能，需要使用许多GCD 的高级功能，大大提高了使用的难度。</p>
<p> <code>Apple</code>  始终有一个观念：尽可能选用高层 API，只在确有必要时才求助于底层。然而开发者并不买账，在我进行的一次 <a href="http://weibo.com/1692391497/D1pKjqaiW?type=comment" target="_blank" rel="noopener">调查</a> 中发现了一个有趣的现象：</p>
<p> 大概 80%的iOS 开发者会支持使用 GCD 来完成操作队列的实现，而且有 60% 的开发已经在项目中使用。</p>
<p> <img src="http://i65.tinypic.com/2vj1md2.jpg" alt="enter image description here"></p>
<p> 更是有人这样表态：</p>
<p> 假如不让他用 GCD：</p>
<p> <img src="http://i66.tinypic.com/34g8qd1.jpg" alt="enter image description here"></p>
<p> 这种现象一直存在，包括 ARC 与 MRC、SB建 UI 与纯代码建 UI、SQL 与 CoreData的争论。</p>
<p> 但是因为是源码解析的文章，而 Parse 的 SDK 没有用一句的 NSOperation 的代码，GCD 一路用到底，让我也十分震惊。只能说明，写  <code>Parse</code>  的这位开发者是艺高人胆大。而且既然  <code>GCD</code>  的支持者如此之多，那么就谈一谈如何让 GCD 能支持 <code>NSOperationQueue</code> 原生就支持的功能。</p>
<p> 今天虽然谈了NSOperation原生功能的 GCD 版本实现，但并不代表我支持像 Parse 这样 GCD 一路用到底。 业内一般的看法是这样的：</p>
<blockquote>
<p> <code>GCD</code> 虽然能够实现暂停和终止，但开发还是灵活些好，那些 <code>NSOperation</code> 用起来方便的就直接用 <code>NSOperation</code> 的方式，不然苹果多包那一层不是蛋疼，包括文章里提到的 <code>iOS8</code> 后控制线程数的问题，不一定项目就一定要GCD一路到底。有时候需要支持一些高层级封装功能比如： <code>KVO</code> 时 <code>NSOperation</code> 还是有它的优势的。 <code>GCD</code> 反而是处理些比较简单的操作或者是较系统级的比如：监视进程或者监视文件夹内文件的变化之类的比较合适。</p>
</blockquote>
<p> （iOS开发学习交流群：541317935）</p>
<p> 第一篇的目的是通过解读 Parse 源码来展示GCD两个高级用法： <code>Dispatch Source</code> （派发源）和 <code>Dispatch Semaphore</code>  （信号量）。首先通过Parse 的“离线存储对象”操作，来介绍 <code>Dispatch Source</code> （派发源）；然后通过Parse 的单元测试中使用的技巧“强制把异步任务转换为同步任务来方便进行单元测试”来介绍<code>Dispatch Semaphore</code>  （信号量）。我已将思路浓缩为可运行的7个 Demo 中，详见仓库里的 Demo1到 Demo7。</p>
<p> 如果对 GCD 不太熟悉，请先读下<a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/GCD扫盲篇.md" target="_blank" rel="noopener">《GCD 扫盲篇》</a>。</p>
<ol>
<li>Dispatch Source分派源</li>
<li><p><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#parse-ios-sdk介绍" target="_blank" rel="noopener">Parse-iOS-SDK介绍</a> </p>
</li>
<li><p><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#parse-的离线存储对象操作介绍" target="_blank" rel="noopener">Parse 的“离线存储对象”操作介绍</a> </p>
</li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#parse-的离线存储对象实现介绍" target="_blank" rel="noopener">Parse 的“离线存储对象”实现介绍</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#dispatch-source-的使用步骤" target="_blank" rel="noopener">Dispatch Source 的使用步骤</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#第一步创建一个dispatch-source" target="_blank" rel="noopener">第一步：创建一个Dispatch Source</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#第二步创建dispatch-source的事件处理方法" target="_blank" rel="noopener">第二步：创建Dispatch Source的事件处理方法</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#第三步处理dispatch-source的暂停与恢复操作" target="_blank" rel="noopener">第三步：处理Dispatch Source的暂停与恢复操作</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#第四步向dispatch-source发送事件" target="_blank" rel="noopener">第四步：向Dispatch Source发送事件</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#gcd真的不能像operationqueue那样终止任务" target="_blank" rel="noopener">GCD真的不能像OperationQueue那样终止任务？</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#完整例子demo1让-dispatch-source-帮-dispatch-queue-实现暂停和恢复功能" target="_blank" rel="noopener">完整例子Demo1：让 Dispatch Source “帮” Dispatch Queue 实现暂停和恢复功能</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#dispatchsource能通过合并事件的方式确保在高负载下正常工作" target="_blank" rel="noopener">DispatchSource能通过合并事件的方式确保在高负载下正常工作</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#dispatch-source-与-dispatch-queue-两者在线程执行上的关系" target="_blank" rel="noopener">Dispatch Source 与 Dispatch Queue 两者在线程执行上的关系</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#让-dispatch-source-与-dispatch-queue-同时实现暂停和恢复" target="_blank" rel="noopener">让 Dispatch Source 与 Dispatch Queue 同时实现暂停和恢复</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#parse-离线存储对象操作的代码摘录" target="_blank" rel="noopener">Parse “离线存储对象”操作的代码摘录</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#dispatch-semaphore-信号量" target="_blank" rel="noopener">Dispatch Semaphore 信号量</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#在项目中的应用强制把异步任务转换为同步任务来方便进行单元测试" target="_blank" rel="noopener">在项目中的应用：强制把异步任务转换为同步任务来方便进行单元测试</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#使用dispatch-semaphore控制并发线程数量" target="_blank" rel="noopener">使用Dispatch Semaphore控制并发线程数量</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#为--nsurlsession-添加同步方法" target="_blank" rel="noopener">为 NSURLSession 添加同步方法</a></li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#导致watchdog超时" target="_blank" rel="noopener">风险：导致Watchdog超时</a> </li>
<li><p><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#失去了-cancel-的机会" target="_blank" rel="noopener">风险：失去了 cancel 的机会</a> </p>
<h2 id="Parse-iOS-SDK介绍"><a href="#Parse-iOS-SDK介绍" class="headerlink" title="Parse-iOS-SDK介绍"></a>Parse-iOS-SDK介绍</h2></li>
</ol>
<p> <a href="http://www.infoq.com/cn/news/2015/08/ios-weekly-ios841#rd" target="_blank" rel="noopener">《iOS开发周报：iOS 8.4.1 发布，iOS 8 时代谢幕》</a> 对 Facebook 旗下的 Parse有这样一段介绍：</p>
<blockquote>
<p>Parse-SDK-iOS-OSX：著名的 BaaS 公司 Parse 最近开源了它们的 iOS/OSX SDK。Parse 的服务虽然在国内可能访问速度不是很理想，但是它们在服务的稳定性和 SDK 质量上一直有非常优异的表现。此次开源的 SDK 对于日常工作是 SDK 开发的开发者来说，是一个难得的学习机会。Parse 的存取操作涉及到很多多线程的问题，从 Parse SDK 的源代码中可以看出，这个 SDK 的开发者对 iOS 开发多线程有着非常深厚的理解和功底，让人叹服。我个人推荐对此感兴趣的朋友可以尝试从阅读 internal 文件夹下的两个EventuallyQueue 文件开始着手，研究下 Parse 的底层多线程处理思路。</p>
</blockquote>
<p> 类似的服务：<br> Apple 的 <a href="http://nshipster.cn/cloudkit/" target="_blank" rel="noopener">Cloud​Kit</a> 、 国内的 <a href="https://leancloud.cn/?source=T6M35E4H" target="_blank" rel="noopener">LeanCloud（原名 <code>AVOS</code> ）</a> 。</p>
<h2 id="Parse-的“离线存储对象”操作介绍"><a href="#Parse-的“离线存储对象”操作介绍" class="headerlink" title="Parse 的“离线存储对象”操作介绍"></a>Parse 的“离线存储对象”操作介绍</h2><p> 大多数保存功能可以立刻执行，并通知应用“保存完毕”。不过若不需要知道保存完成的时间，则可使用“离线存储对象”操作（saveEventually 或 deleteEventually） 来代替，也就是：</p>
<p> 如果用户目前尚未接入网络，“离线存储对象”操作（saveEventually 或 deleteEventually） 会缓存设备中的数据，并在网络连接恢复后上传。如果应用在网络恢复之前就被关闭了，那么当它下一次打开时，SDK 会自动再次尝试保存操作。</p>
<p> 所有 saveEventually（或 deleteEventually）的相关调用，将按照调用的顺序依次执行。因此，多次对某一对象使用 saveEventually 是安全的。</p>
<p> 国内的 <a href="https://leancloud.cn/?source=T6M35E4H" target="_blank" rel="noopener">LeanCloud（原名 <code>AVOS</code> ）</a> 也提供了相同的功能，所以以上《Parse 的“离线存储对象”操作介绍》部分完全摘录自 LeanCloud 的文档。详见<a href="https://leancloud.cn/docs/ios_os_x_guide.html#离线存储对象" target="_blank" rel="noopener">《LeanCloud官方文档-iOS / OS X 数据存储开发指南–离线存储对象》</a> </p>
<p> （利益相关声明：本人目前就职于 <a href="https://leancloud.cn/?source=T6M35E4H" target="_blank" rel="noopener">LeanCloud（原名 <code>AVOS</code> ）</a> ）</p>
<h2 id="Parse-的“离线存储对象”实现介绍"><a href="#Parse-的“离线存储对象”实现介绍" class="headerlink" title="Parse 的“离线存储对象”实现介绍"></a>Parse 的“离线存储对象”实现介绍</h2><p> Parse 的“离线存储对象”操作（saveEventually 或 deleteEventually） 是通过 GCD 的 <code>Dispatch Source</code> （信号源）来实现的。下面对 <code>Dispatch Source</code> （信号源）进行一下介绍：</p>
<p> GCD中除了主要的 <code>Dispatch Queue</code> 外，还有不太引人注目的 <code>Dispatch Source</code> .它是BSD系内核惯有功能kqueue的包装。kqueue 是在 XNU 内核中发生各种事件时，在应用程序编程方执行处理的技术。其 CPU 负荷非常小，尽量不占用资源。kqueue 可以说是应用程序处理 XNU 内核中发生的各种事件的方法中最优秀的一种。</p>
<p> <code>Dispatch Source</code> 也使用在了 Core Foundation 框架的用于异步网络的API  <code>CFSocket</code> 中。因为Foundation 框架的异步网络 API 是通过CFSocket实现的，所以可享受到仅使用 Foundation 框架的 <code>Dispatch Source</code> 带来的好处。</p>
<p> 那么优势何在？使用的 <code>Dispatch Source</code> 而不使用 <code>dispatch_async</code> 的唯一原因就是利用联结的优势。</p>
<p> 联结的大致流程：在任一线程上调用它的的一个函数 <code>dispatch_source_merge_data</code>  后，会执行 <code>Dispatch Source</code> 事先定义好的句柄（可以把句柄简单理解为一个 block ）。</p>
<p> 这个过程叫 <code>Custom event</code> ,用户事件。是 dispatch source 支持处理的一种事件。</p>
<blockquote>
<p>简单地说，这种事件是由你调用 <code>dispatch_source_merge_data</code> 函数来向自己发出的信号。</p>
</blockquote>
<p> 下面介绍下使用步骤：</p>
<h2 id="Dispatch-Source-的使用步骤"><a href="#Dispatch-Source-的使用步骤" class="headerlink" title="Dispatch Source 的使用步骤"></a><code>Dispatch Source</code> 的使用步骤</h2><h3 id="第一步：创建一个Dispatch-Source"><a href="#第一步：创建一个Dispatch-Source" class="headerlink" title="第一步：创建一个Dispatch Source"></a>第一步：创建一个<code>Dispatch Source</code></h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 详见 Demo1、Demo2</span><br><span class="line">// 指定DISPATCH_SOURCE_TYPE_DATA_ADD，做成Dispatch Source(分派源)。设定Main Dispatch Queue 为追加处理的Dispatch Queue</span><br><span class="line">_processingQueueSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0,</span><br><span class="line">dispatch_get_main_queue());</span><br></pre></td></tr></table></figure>
<p> 下面对参数进行下解释：</p>
<p> 其中自定义源累积事件中传递过来的值，累积的方式可以是相加的，正如上面代码中的 <code>DISPATCH_SOURCE_TYPE_DATA_ADD</code> ，也可以是逻辑或 <code>DISPATCH_SOURCE_TYPE_DATA_OR</code> 。这是最常见的两个 <code>Dispatch Source</code> 可以处理的事件。</p>
<p> <code>Dispatch Source</code> 可处理的所有事件。如下表所示：</p>
<table>
<thead>
<tr>
<th></th>
<th>名称</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>DISPATCH_SOURCE_TYPE_DATA_ADD</code></td>
<td>变量增加</td>
</tr>
<tr>
<td> <code>DISPATCH_SOURCE_TYPE_DATA_OR</code></td>
<td>变量OR</td>
</tr>
<tr>
<td> <code>DISPATCH_SOURCE_TYPE_MACH_SEND</code></td>
<td>MACH端口发送</td>
</tr>
<tr>
<td> <code>DISPATCH_SOURCE_TYPE_MACH_RECV</code></td>
<td>MACH端口接收</td>
</tr>
<tr>
<td> <code>DISPATCH_SOURCE_TYPE_PROC</code></td>
<td>监测到与进程相关的事件</td>
</tr>
<tr>
<td> <code>DISPATCH_SOURCE_TYPE_READ</code></td>
<td>可读取文件映像</td>
</tr>
<tr>
<td> <code>DISPATCH_SOURCE_TYPE_SIGNAL</code></td>
<td>接收信号</td>
</tr>
<tr>
<td> <code>DISPATCH_SOURCE_TYPE_TIMER</code></td>
<td>定时器</td>
</tr>
<tr>
<td> <code>DISPATCH_SOURCE_TYPE_VNODE</code></td>
<td>文件系统有变更</td>
</tr>
<tr>
<td> <code>DISPATCH_SOURCE_TYPE_WRITE</code></td>
<td>可写入文件映像</td>
</tr>
</tbody>
</table>
<p> 自定义源也需要一个队列，用来处理所有的响应句柄（block）。那么岂不是有两个队列了？没错，至于 <code>Dispatch Queue</code> 这个队列的线程执行与  <code>Dispatch Source</code>这个队列的线程执行的关系，下文会结合 Demo1和 Demo2进行详细论述。</p>
<h3 id="第二步：创建Dispatch-Source的事件处理方法"><a href="#第二步：创建Dispatch-Source的事件处理方法" class="headerlink" title="第二步：创建Dispatch Source的事件处理方法"></a>第二步：创建<code>Dispatch Source</code>的事件处理方法</h3><p> 分派源提供了高效的方式来处理事件。首先注册事件处理程序，事件发生时会收到通知。如果在系统还没有来得及通知你之前事件就发生了多次，那么这些事件会被合并为一个事件。这对于底层的高性能代码很有用，但是OS应用开发者很少会用到这样的功能。类似地，分派源可以响应UNIX信号、文件系统的变化、其他进程的变化以及Mach Port事件。它们中很多都在Mac系统上很有用，但是iOS开发者通常不会用到。</p>
<p> 不过，自定义源在iOS中很有用，尤其是在性能至关重要的场合进行进度反馈。如下所示，首先创建一个源:自定义源累积事件中传递过来的值。累积方式可以是相加( DISPATCH_SOURCE_TYPE_DATA_ADD ),<br> 也可以是逻辑或( DISPATCH_SOURCE_DATA_OR )。自定义源也需要一个队列，用来处理所有的响应处理块。</p>
<p> 创建源后，需要提供相应的处理方法。当源生效时会分派注册处理方法;当事件发生时会分派事件处理方法;当源被取消时会分派取消处理方法。自定义源通常只需要一个事件处理方法，可以像这样创建:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line">*省略部分： </span><br><span class="line">指定DISPATCH_SOURCE_TYPE_DATA_ADD，做成Dispatch Source(分派源)。设定Main Dispatch Queue 为追加处理的Dispatch Queue</span><br><span class="line">详见Demo1、Demo2</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">__block NSUInteger totalComplete = 0;</span><br><span class="line">dispatch_source_set_event_handler(_processingQueueSource, ^&#123;</span><br><span class="line">//当处理事件被最终执行时，计算后的数据可以通过dispatch_source_get_data来获取。这个数据的值在每次响应事件执行后会被重置，所以totalComplete的值是最终累积的值。</span><br><span class="line">NSUInteger value = dispatch_source_get_data(_processingQueueSource);</span><br><span class="line">totalComplete += value;</span><br><span class="line">NSLog(@&quot;进度：%@&quot;, @((CGFloat)totalComplete/100));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p> 在同一时间，只有一个处理方法块的实例被分派。如果这个处理方法还没有执行完毕，另一个事件就发生了，事件会以指定方式(ADD或者OR)进行累积。通过合并事件的方式，系统即使在高负<br> 载情况下也能正常工作。当处理事件件被最终执行时，计算后的数据可以通过 <code>dispatch_source_get_data</code> 来获取。这个数据的值在每次响应事件执行后会被重置，所以上面例子中 <code>totalComplete</code> 的值是最终累积的值。</p>
<h3 id="第三步：处理Dispatch-Source的暂停与恢复操作"><a href="#第三步：处理Dispatch-Source的暂停与恢复操作" class="headerlink" title="第三步：处理Dispatch Source的暂停与恢复操作"></a>第三步：处理<code>Dispatch Source</code>的暂停与恢复操作</h3><p> 当追加大量处理到Dispatch Queue时，在追加处理的过程中，有时希望不执行已追加的处理。例如演算结果被Block截获时，一些处理会对这个演算结果造成影响。</p>
<p> 在这种情况下，只要挂起Dispatch Queue即可。当可以执行时再恢复。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_suspend(queue);</span><br></pre></td></tr></table></figure>
<p> <code>dispatch_resume</code> 函数恢复指定的 <code>Dispatch Queue</code> .<br> 这些函数对已经执行的处理没有影响。挂起后，追加到 <code>Dispatch Queue</code> 中但尚未执行的处理在此之后停止执行。而恢复则使得这些处理能够继续执行。</p>
<p> 分派源创建时默认处于暂停状态，在分派源分派处理程序之前必须先恢复。因为忘记恢复分派源的状态而产生bug是常见的事儿。恢复的方法是调用 <code>dispatch_resume</code> :</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_resume (source);</span><br></pre></td></tr></table></figure>
<p> 为了方便理解 <code>dispatch_suspend</code> 函数的作用，这里提供一个 Demo：Demo3， 看下运行效果：</p>
<p> 思考下NSLog的打印顺序为什么会是这样？</p>
<p> 详见 Demo3（Demo_03_对DispatchQueue实现取消恢复操作_简单版）：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.iOSChengXuYuan.queue1&quot;, 0);</span><br><span class="line">dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.iOSChengXuYuan.queue2&quot;, 0);</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">dispatch_async(queue1, ^&#123;</span><br><span class="line">NSLog(@&quot;任务 1 ： queue 1...&quot;);</span><br><span class="line">sleep(1);</span><br><span class="line">NSLog(@&quot;✅完成任务 1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue2, ^&#123;</span><br><span class="line">NSLog(@&quot;任务 1 ： queue 2...&quot;);</span><br><span class="line">sleep(1);</span><br><span class="line">NSLog(@&quot;✅完成任务 2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue1, ^&#123;</span><br><span class="line">NSLog(@&quot;🚫正在暂停 1&quot;);</span><br><span class="line">dispatch_suspend(queue1);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue2, ^&#123;</span><br><span class="line">NSLog(@&quot;🚫正在暂停 2&quot;);</span><br><span class="line">dispatch_suspend(queue2);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">NSLog(@&quot;＝＝＝＝＝＝＝等待两个queue完成, 再往下进行...&quot;);</span><br><span class="line">dispatch_async(queue1, ^&#123;</span><br><span class="line">NSLog(@&quot;任务 2 ： queue 1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue2, ^&#123;</span><br><span class="line">NSLog(@&quot;任务 2 ： queue 2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;🔴为什么这个NSLog会在上面两个NSLog之前打印❓❓答：dispatch_suspend的作用‼️&quot;);</span><br><span class="line"></span><br><span class="line">dispatch_resume(queue1);</span><br><span class="line">dispatch_resume(queue2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 打印：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2015-09-06 02:44:59.614 CYLDispatchQueueSuspendTest[1610:116662] 任务 1 ： queue 2...</span><br><span class="line">2015-09-06 02:44:59.613 CYLDispatchQueueSuspendTest[1610:116665] 任务 1 ： queue 1...</span><br><span class="line">2015-09-06 02:45:00.614 CYLDispatchQueueSuspendTest[1610:116665] ✅完成任务 1</span><br><span class="line">2015-09-06 02:45:00.614 CYLDispatchQueueSuspendTest[1610:116662] ✅完成任务 2</span><br><span class="line">2015-09-06 02:45:00.616 CYLDispatchQueueSuspendTest[1610:116662] 🚫正在暂停 2</span><br><span class="line">2015-09-06 02:45:00.615 CYLDispatchQueueSuspendTest[1610:116665] 🚫正在暂停 1</span><br><span class="line">2015-09-06 02:45:00.616 CYLDispatchQueueSuspendTest[1610:116515] ＝＝＝＝＝＝＝等待两个queue完成, 再往下进行...</span><br><span class="line">2015-09-06 02:45:00.616 CYLDispatchQueueSuspendTest[1610:116515] 🔴为什么这个NSLog会在上面两个NSLog之前打印❓❓答：dispatch_suspend的作用‼️</span><br><span class="line">2015-09-06 02:45:00.617 CYLDispatchQueueSuspendTest[1610:116665] 任务 2 ： queue 1</span><br><span class="line">2015-09-06 02:45:00.619 CYLDispatchQueueSuspendTest[1610:116665] 任务 2 ： queue 2</span><br></pre></td></tr></table></figure>
<p> 思考下NSLog的打印顺序为什么会是这样？答：dispatch_suspend的作用！</p>
<p> 详见 Demo3（Demo_03_对DispatchQueue实现取消恢复操作_简单版）。</p>
<h3 id="第四步：向Dispatch-Source发送事件"><a href="#第四步：向Dispatch-Source发送事件" class="headerlink" title="第四步：向Dispatch Source发送事件"></a>第四步：向<code>Dispatch Source</code>发送事件</h3><p> 恢复源后，就可以像下面的代码片段这样，通过 <code>dispatch_source_merge_data</code> 向分派源发送事件:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//2.</span><br><span class="line">//恢复源后，就可以通过dispatch_source_merge_data向Dispatch Source(分派源)发送事件:</span><br><span class="line">//详见Demo1、Demo2</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">for (NSUInteger index = 0; index &lt; 100; index++) &#123;</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">dispatch_source_merge_data(_processingQueueSource, 1);</span><br><span class="line">usleep(20000);//0.02秒</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 上面代码在每次循环中执行加1操作。也可以传递已处理记录的数目或已写入的字节数。在任何线程中都可以调用  <code>dispatch_source_merge_data</code> 。需要注意的是，不可以传递0值(事件不会被触发)，同样也不可以传递负数。</p>
<h1 id="GCD真的不能像OperationQueue那样终止任务？"><a href="#GCD真的不能像OperationQueue那样终止任务？" class="headerlink" title="GCD真的不能像OperationQueue那样终止任务？"></a>GCD真的不能像OperationQueue那样终止任务？</h1><h3 id="完整例子Demo1：让-Dispatch-Source-“帮”-Dispatch-Queue-实现暂停和恢复功能"><a href="#完整例子Demo1：让-Dispatch-Source-“帮”-Dispatch-Queue-实现暂停和恢复功能" class="headerlink" title="完整例子Demo1：让 Dispatch Source “帮” Dispatch Queue 实现暂停和恢复功能"></a>完整例子Demo1：让 Dispatch Source “帮” Dispatch Queue 实现暂停和恢复功能</h3><p> 本节配套代码在 <code>Demo1</code> 中（Demo_01_对DispatchSource实现取消恢复操作_main队列版）。</p>
<p> 先写一段代码演示下DispatchSource的基本用法：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  .m</span><br><span class="line">//  CYLDispatchSourceTest</span><br><span class="line">//</span><br><span class="line">//  Created by 微博@iOS程序犭袁（ http://weibo.com/luohanchenyilong/） on 15/9/1.</span><br><span class="line">//  Copyright (c) 2015年 https://github.com/ChenYilong . All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">//1.</span><br><span class="line">// 指定DISPATCH_SOURCE_TYPE_DATA_ADD，做成Dispatch Source(分派源)。设定Main Dispatch Queue 为追加处理的Dispatch Queue</span><br><span class="line">_processingQueueSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0,</span><br><span class="line">dispatch_get_main_queue());</span><br><span class="line">__block NSUInteger totalComplete = 0;</span><br><span class="line">dispatch_source_set_event_handler(_processingQueueSource, ^&#123;</span><br><span class="line">//当处理事件被最终执行时，计算后的数据可以通过dispatch_source_get_data来获取。这个数据的值在每次响应事件执行后会被重置，所以totalComplete的值是最终累积的值。</span><br><span class="line">NSUInteger value = dispatch_source_get_data(_processingQueueSource);</span><br><span class="line">totalComplete += value;</span><br><span class="line">NSLog(@&quot;进度：%@&quot;, @((CGFloat)totalComplete/100));</span><br><span class="line">NSLog(@&quot;🔵线程号：%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">//分派源创建时默认处于暂停状态，在分派源分派处理程序之前必须先恢复。</span><br><span class="line">[self resume];</span><br><span class="line"></span><br><span class="line">//2.</span><br><span class="line">//恢复源后，就可以通过dispatch_source_merge_data向Dispatch Source(分派源)发送事件:</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">for (NSUInteger index = 0; index &lt; 100; index++) &#123;</span><br><span class="line">dispatch_source_merge_data(_processingQueueSource, 1);</span><br><span class="line">NSLog(@&quot;♻️线程号：%@&quot;, [NSThread currentThread]);</span><br><span class="line">usleep(20000);//0.02秒</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 则输出日志：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">2015-09-03 16:50:48.346 CYLDispatchSourceTest[8331:874681] ✅恢复Dispatch Source(分派源)</span><br><span class="line">2015-09-03 16:50:48.348 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:48.372 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:48.401 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:48.424 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:48.444 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:48.473 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:48.493 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:48.515 CYLDispatchSourceTest[8331:874681] 进度：0.07000000000000001</span><br><span class="line">2015-09-03 16:50:48.515 CYLDispatchSourceTest[8331:874681] 🔵线程号：&lt;NSThread: 0x7ff373428140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:50:48.516 CYLDispatchSourceTest[8331:874681] 进度：0.08</span><br><span class="line">2015-09-03 16:50:48.516 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:48.535 CYLDispatchSourceTest[8331:874681] 🔵线程号：&lt;NSThread: 0x7ff373428140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:50:48.556 CYLDispatchSourceTest[8331:874681] 进度：0.09</span><br><span class="line">/*================省略中间====================*/</span><br><span class="line">2015-09-03 16:50:50.630 CYLDispatchSourceTest[8331:874681] 🔵线程号：&lt;NSThread: 0x7ff373428140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:50:50.630 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:50.654 CYLDispatchSourceTest[8331:874681] 进度：0.97</span><br><span class="line">2015-09-03 16:50:50.654 CYLDispatchSourceTest[8331:874681] 🔵线程号：&lt;NSThread: 0x7ff373428140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:50:50.654 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:50.676 CYLDispatchSourceTest[8331:874681] 进度：0.98</span><br><span class="line">2015-09-03 16:50:50.676 CYLDispatchSourceTest[8331:874681] 🔵线程号：&lt;NSThread: 0x7ff373428140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:50:50.676 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:50.699 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:50.708 CYLDispatchSourceTest[8331:874681] 进度：0.99</span><br><span class="line">2015-09-03 16:50:50.708 CYLDispatchSourceTest[8331:874681] 🔵线程号：&lt;NSThread: 0x7ff373428140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:50:50.722 CYLDispatchSourceTest[8331:874681] 进度：1</span><br><span class="line">2015-09-03 16:50:50.722 CYLDispatchSourceTest[8331:874681] 🔵线程号：&lt;NSThread: 0x7ff373428140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:50:50.722 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p> 耗时：2.376</p>
<p> 这段代码还可以进行如下优化：</p>
<p> 将创建异步的操作放在 for 循环内部：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">//1.</span><br><span class="line">// 指定DISPATCH_SOURCE_TYPE_DATA_ADD，做成Dispatch Source(分派源)。设定Main Dispatch Queue 为追加处理的Dispatch Queue</span><br><span class="line">_processingQueueSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0,</span><br><span class="line">dispatch_get_main_queue());</span><br><span class="line">__block NSUInteger totalComplete = 0;</span><br><span class="line">dispatch_source_set_event_handler(_processingQueueSource, ^&#123;</span><br><span class="line">//当处理事件被最终执行时，计算后的数据可以通过dispatch_source_get_data来获取。这个数据的值在每次响应事件执行后会被重置，所以totalComplete的值是最终累积的值。</span><br><span class="line">NSUInteger value = dispatch_source_get_data(_processingQueueSource);</span><br><span class="line">totalComplete += value;</span><br><span class="line">NSLog(@&quot;进度：%@&quot;, @((CGFloat)totalComplete/100));</span><br><span class="line">NSLog(@&quot;🔵线程号：%@&quot;, [NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">//分派源创建时默认处于暂停状态，在分派源分派处理程序之前必须先恢复。</span><br><span class="line">[self resume];</span><br><span class="line"></span><br><span class="line">//2.</span><br><span class="line">//恢复源后，就可以通过dispatch_source_merge_data向Dispatch Source(分派源)发送事件:</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">for (NSUInteger index = 0; index &lt; 100; index++) &#123;</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">dispatch_source_merge_data(_processingQueueSource, 1);</span><br><span class="line">NSLog(@&quot;♻️线程号：%@&quot;, [NSThread currentThread]);</span><br><span class="line">usleep(20000);//0.02秒</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 执行结果：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">2015-09-03 16:48:10.153 CYLDispatchSourceTest[8301:871133] ✅恢复Dispatch Source(分派源)</span><br><span class="line">2015-09-03 16:48:10.154 CYLDispatchSourceTest[8301:871174] ♻️线程号：&lt;NSThread: 0x7fb663616c50&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.156 CYLDispatchSourceTest[8301:871177] ♻️线程号：&lt;NSThread: 0x7fb663417370&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.156 CYLDispatchSourceTest[8301:871176] ♻️线程号：&lt;NSThread: 0x7fb66359ac80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.163 CYLDispatchSourceTest[8301:871184] ♻️线程号：&lt;NSThread: 0x7fb6635507b0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.164 CYLDispatchSourceTest[8301:871185] ♻️线程号：&lt;NSThread: 0x7fb663618c90&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.164 CYLDispatchSourceTest[8301:871186] ♻️线程号：&lt;NSThread: 0x7fb663596920&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.174 CYLDispatchSourceTest[8301:871187] ♻️线程号：&lt;NSThread: 0x7fb663465d20&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.174 CYLDispatchSourceTest[8301:871175] ♻️线程号：&lt;NSThread: 0x7fb6634404f0&gt;&#123;number = 9, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.182 CYLDispatchSourceTest[8301:871133] 进度：0.09</span><br><span class="line">2015-09-03 16:48:10.174 CYLDispatchSourceTest[8301:871174] ♻️线程号：&lt;NSThread: 0x7fb663616c50&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.187 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.184 CYLDispatchSourceTest[8301:871188] ♻️线程号：&lt;NSThread: 0x7fb66348e850&gt;&#123;number = 10, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.184 CYLDispatchSourceTest[8301:871177] ♻️线程号：&lt;NSThread: 0x7fb663417370&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.191 CYLDispatchSourceTest[8301:871133] 进度：0.13</span><br><span class="line">2015-09-03 16:48:10.187 CYLDispatchSourceTest[8301:871192] ♻️线程号：&lt;NSThread: 0x7fb66348db80&gt;&#123;number = 11, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.191 CYLDispatchSourceTest[8301:871189] ♻️线程号：&lt;NSThread: 0x7fb6635121b0&gt;&#123;number = 12, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.191 CYLDispatchSourceTest[8301:871176] ♻️线程号：&lt;NSThread: 0x7fb66359ac80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.196 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.192 CYLDispatchSourceTest[8301:871184] ♻️线程号：&lt;NSThread: 0x7fb6635507b0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.192 CYLDispatchSourceTest[8301:871185] ♻️线程号：&lt;NSThread: 0x7fb663618c90&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.192 CYLDispatchSourceTest[8301:871186] ♻️线程号：&lt;NSThread: 0x7fb663596920&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.194 CYLDispatchSourceTest[8301:871190] ♻️线程号：&lt;NSThread: 0x7fb6635138b0&gt;&#123;number = 13, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.196 CYLDispatchSourceTest[8301:871187] ♻️线程号：&lt;NSThread: 0x7fb663465d20&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.196 CYLDispatchSourceTest[8301:871175] ♻️线程号：&lt;NSThread: 0x7fb6634404f0&gt;&#123;number = 9, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.206 CYLDispatchSourceTest[8301:871133] 进度：0.21</span><br><span class="line">2015-09-03 16:48:10.207 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.210 CYLDispatchSourceTest[8301:871133] 进度：0.23</span><br><span class="line">2015-09-03 16:48:10.201 CYLDispatchSourceTest[8301:871193] ♻️线程号：&lt;NSThread: 0x7fb663487830&gt;&#123;number = 14, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.207 CYLDispatchSourceTest[8301:871194] ♻️线程号：&lt;NSThread: 0x7fb6634662c0&gt;&#123;number = 15, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.207 CYLDispatchSourceTest[8301:871195] ♻️线程号：&lt;NSThread: 0x7fb663618160&gt;&#123;number = 16, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.211 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.210 CYLDispatchSourceTest[8301:871196] ♻️线程号：&lt;NSThread: 0x7fb663566720&gt;&#123;number = 17, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.211 CYLDispatchSourceTest[8301:871174] ♻️线程号：&lt;NSThread: 0x7fb663616c50&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">/*＝＝＝＝＝＝＝＝＝＝省略20行带有的 ♻️的打印内容（没有重复的线程号）＝＝＝＝＝＝＝＝*/</span><br><span class="line">2015-09-03 16:48:10.239 CYLDispatchSourceTest[8301:871196] ♻️线程号：&lt;NSThread: 0x7fb663566720&gt;&#123;number = 17, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.239 CYLDispatchSourceTest[8301:871174] ♻️线程号：&lt;NSThread: 0x7fb663616c50&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.239 CYLDispatchSourceTest[8301:871191] ♻️线程号：&lt;NSThread: 0x7fb663597ca0&gt;&#123;number = 18, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.245 CYLDispatchSourceTest[8301:871202] ♻️线程号：&lt;NSThread: 0x7fb663617c00&gt;&#123;number = 24, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.247 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.249 CYLDispatchSourceTest[8301:871133] 进度：0.5</span><br><span class="line">2015-09-03 16:48:10.249 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.248 CYLDispatchSourceTest[8301:871203] ♻️线程号：&lt;NSThread: 0x7fb663531ab0&gt;&#123;number = 25, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.249 CYLDispatchSourceTest[8301:871133] 进度：0.51</span><br><span class="line">2015-09-03 16:48:10.249 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.250 CYLDispatchSourceTest[8301:871204] ♻️线程号：&lt;NSThread: 0x7fb66344bbf0&gt;&#123;number = 26, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.250 CYLDispatchSourceTest[8301:871133] 进度：0.52</span><br><span class="line">2015-09-03 16:48:10.251 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.251 CYLDispatchSourceTest[8301:871133] 进度：0.53</span><br><span class="line">2015-09-03 16:48:10.250 CYLDispatchSourceTest[8301:871205] ♻️线程号：&lt;NSThread: 0x7fb663461d90&gt;&#123;number = 27, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.251 CYLDispatchSourceTest[8301:871206] ♻️线程号：&lt;NSThread: 0x7fb66341d370&gt;&#123;number = 28, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.252 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.252 CYLDispatchSourceTest[8301:871133] 进度：0.54</span><br><span class="line">2015-09-03 16:48:10.251 CYLDispatchSourceTest[8301:871207] ♻️线程号：&lt;NSThread: 0x7fb6634196e0&gt;&#123;number = 29, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.253 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.254 CYLDispatchSourceTest[8301:871133] 进度：0.57</span><br><span class="line">2015-09-03 16:48:10.254 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.255 CYLDispatchSourceTest[8301:871133] 进度：0.58</span><br><span class="line">2015-09-03 16:48:10.252 CYLDispatchSourceTest[8301:871208] ♻️线程号：&lt;NSThread: 0x7fb66341bd50&gt;&#123;number = 30, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.253 CYLDispatchSourceTest[8301:871209] ♻️线程号：&lt;NSThread: 0x7fb66361a070&gt;&#123;number = 31, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.253 CYLDispatchSourceTest[8301:871210] ♻️线程号：&lt;NSThread: 0x7fb663618020&gt;&#123;number = 32, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.255 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.255 CYLDispatchSourceTest[8301:871211] ♻️线程号：&lt;NSThread: 0x7fb663612c90&gt;&#123;number = 33, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.256 CYLDispatchSourceTest[8301:871133] 进度：0.59</span><br><span class="line">2015-09-03 16:48:10.257 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.256 CYLDispatchSourceTest[8301:871212] ♻️线程号：&lt;NSThread: 0x7fb6635996d0&gt;&#123;number = 34, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.259 CYLDispatchSourceTest[8301:871133] 进度：0.6</span><br><span class="line">2015-09-03 16:48:10.259 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.259 CYLDispatchSourceTest[8301:871213] ♻️线程号：&lt;NSThread: 0x7fb66340bd30&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.260 CYLDispatchSourceTest[8301:871133] 进度：0.61</span><br><span class="line">2015-09-03 16:48:10.264 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.262 CYLDispatchSourceTest[8301:871214] ♻️线程号：&lt;NSThread: 0x7fb66354f4b0&gt;&#123;number = 36, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.264 CYLDispatchSourceTest[8301:871133] 进度：0.62</span><br><span class="line">2015-09-03 16:48:10.264 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.264 CYLDispatchSourceTest[8301:871215] ♻️线程号：&lt;NSThread: 0x7fb663531010&gt;&#123;number = 37, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.270 CYLDispatchSourceTest[8301:871133] 进度：0.63</span><br><span class="line">2015-09-03 16:48:10.270 CYLDispatchSourceTest[8301:871216] ♻️线程号：&lt;NSThread: 0x7fb66360c6e0&gt;&#123;number = 38, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.270 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.270 CYLDispatchSourceTest[8301:871176] ♻️线程号：&lt;NSThread: 0x7fb66359ac80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.270 CYLDispatchSourceTest[8301:871133] 进度：0.64</span><br><span class="line">2015-09-03 16:48:10.271 CYLDispatchSourceTest[8301:871198] ♻️线程号：&lt;NSThread: 0x7fb663576ab0&gt;&#123;number = 20, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.271 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.271 CYLDispatchSourceTest[8301:871189] ♻️线程号：&lt;NSThread: 0x7fb6635121b0&gt;&#123;number = 12, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.271 CYLDispatchSourceTest[8301:871188] ♻️线程号：&lt;NSThread: 0x7fb66348e850&gt;&#123;number = 10, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.271 CYLDispatchSourceTest[8301:871192] ♻️线程号：&lt;NSThread: 0x7fb66348db80&gt;&#123;number = 11, name = (null)&#125;</span><br><span class="line">/*＝＝＝＝＝＝＝＝＝＝省略30行带有的 ♻️的打印内容（没有重复的线程号）＝＝＝＝＝＝＝＝*/</span><br><span class="line">2015-09-03 16:48:10.277 CYLDispatchSourceTest[8301:871222] ♻️线程号：&lt;NSThread: 0x7fb66361ca00&gt;&#123;number = 43, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.278 CYLDispatchSourceTest[8301:871223] ♻️线程号：&lt;NSThread: 0x7fb66360c620&gt;&#123;number = 44, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.290 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.293 CYLDispatchSourceTest[8301:871133] 进度：1</span><br><span class="line">2015-09-03 16:48:10.293 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>
<p> 耗时：0.14秒，与之前的2.376秒相比，时间是后者的17倍 ，性能相差很大。</p>
<h3 id="DispatchSource能通过合并事件的方式确保在高负载下正常工作"><a href="#DispatchSource能通过合并事件的方式确保在高负载下正常工作" class="headerlink" title="DispatchSource能通过合并事件的方式确保在高负载下正常工作"></a>DispatchSource能通过合并事件的方式确保在高负载下正常工作</h3><p> 然而上例中也因为并发执行，速度相当快，调用 <code>dispatch_source_merge_data</code> 后所触发的 <code>dispatch_source_set_event_handler</code> 的频率也大大减少，有时只会在结束时触发一次。</p>
<p> 如果你细心观察下上例中的打印🔵（小蓝点）♻️（小绿点）个数是不一的，但 <code>totalComplete</code> 的值，或者进度条从0.0到1.0的执行是正常，但是🔵（小蓝点）为什么没有被打印？这是因为：</p>
<blockquote>
<p>DispatchSource能通过合并事件的方式确保在高负载下正常工作</p>
</blockquote>
<p> 在同一时间，只有一个处理 block 的实例被分配，如果这个处理方法还没有执行完毕，另一个事件就发生了，事件会以指定方式（ADD或 OR）进行累积。DispatchSource能通过合并事件（block）的方式确保在高负载下正常工作。当处理事件被最终执行时，计算后的数据可以通过 <code>dispatch_source_get_data</code> 来获取。这个数据的值在每次响应时间执行后会被重置，所以上面的例子中进度条 <code>totalComplete</code> 的值是最终积累的值，而 block 不是每次都执行的，但打印🔵（小蓝点）♻️（小绿点）个数不一。但能确保进度条能从0.0到1.0的正常执行。</p>
<p> 下面我们来演示下如何控制Dispatch Source(分派源)，让它随时暂停，随时恢复：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">[super didReceiveMemoryWarning];</span><br><span class="line">[self changeStatus:self.running];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)changeStatus:(BOOL)shouldPause &#123;</span><br><span class="line">if (shouldPause) &#123;</span><br><span class="line">[self pause];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">[self resume];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)resume &#123;</span><br><span class="line">if (self.running) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;✅恢复Dispatch Source(分派源)&quot;);</span><br><span class="line">self.running = YES;</span><br><span class="line">dispatch_resume(_processingQueueSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)pause &#123;</span><br><span class="line">if (!self.running) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;🚫暂停Dispatch Source(分派源)&quot;);</span><br><span class="line">self.running = NO;</span><br><span class="line">dispatch_suspend(_processingQueueSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 并取消打印线程的 <code>NSLog</code> ，然后使用下图中的快捷键迅速触发 <code>didReceiveMemoryWarning</code>  以切换Dispatch Source(分派源)的状态:</p>
<p> <img src="http://i61.tinypic.com/6thjmf.jpg" alt="enter image description here"></p>
<p> <img src="http://i59.tinypic.com/suyt0o.jpg" alt="enter image description here"></p>
<p> 详见 <code>Demo1</code> 实现（Demo_01_对DispatchSource实现取消恢复操作_main队列版）。</p>
<h3 id="Dispatch-Source-与-Dispatch-Queue-两者在线程执行上的关系"><a href="#Dispatch-Source-与-Dispatch-Queue-两者在线程执行上的关系" class="headerlink" title="Dispatch Source 与 Dispatch Queue 两者在线程执行上的关系"></a>Dispatch Source 与 Dispatch Queue 两者在线程执行上的关系</h3><p> 本节配套代码在  <code>Demo2</code> 中（Demo_02_对DispatchSource实现取消恢复操作_global队列版）。</p>
<p> 答案是：没有关系。两者会独立运行。 Dispatch Queue 像一个生产任务的生产者，而 Dispatch Source 像处理任务的消费者。可以一边异步生产，也可一边异步消费。你可以在任意线程上调用 <code>dispatch_source_merge_data</code> 以触发 <code>dispatch_source_set_event_handler</code> 。而句柄的执行线程，取决于你创建句柄时所指定的线程，如果你像下面这样创建，那么句柄会在主线程执行：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 指定DISPATCH_SOURCE_TYPE_DATA_ADD，做成Dispatch Source(分派源)。设定Main Dispatch Queue 为追加处理的 Dispatch Queue</span><br><span class="line">_processingQueueSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0,</span><br><span class="line">dispatch_get_main_queue());</span><br></pre></td></tr></table></figure>
<p> 如果你像下面这样创建，那么句柄会在异步线程执行：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 指定DISPATCH_SOURCE_TYPE_DATA_ADD，做成Dispatch Source(分派源)。设定 global Dispatch Queue 为追加处理的Dispatch Queue</span><br><span class="line">_processingQueueSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0,</span><br><span class="line">dispatch_get_global_queue(0, 0));</span><br></pre></td></tr></table></figure>
<p> 详见 <code>Demo2</code> 实现（Demo_02_对DispatchSource实现取消恢复操作_global队列版）</p>
<h3 id="让-Dispatch-Source-与-Dispatch-Queue-同时实现暂停和恢复"><a href="#让-Dispatch-Source-与-Dispatch-Queue-同时实现暂停和恢复" class="headerlink" title="让 Dispatch Source 与 Dispatch Queue 同时实现暂停和恢复"></a>让 Dispatch Source 与 Dispatch Queue 同时实现暂停和恢复</h3><p> 本节代码详见 Demo4（Demo_04_对DispatchQueue实现取消恢复操作_综合版）</p>
<p> 你可能已经发现了：上面的代码是有问题的，它只是一种“假暂停”的状态。for 循环还是要执行100遍，循环的次数并没有因你暂停了派发源而暂停，这在实际开发中是不允许的，因为真正的性能瓶颈永远会是在这里，这样的暂停毫无意义。那么如何让 for 循环随时可以暂停？</p>
<p> 实际上 <code>Dispatch Queue</code> 没有“取消”这一概念。一旦将处理追加到 <code>Dispatch Queue</code> 中，就没有方法可将该处理去除，也没有方法可在执行中取消该处理。编程人员要么在处理中导入取消这一概念。</p>
<p> 要么放弃取消，或者使用 <code>NSOperationQueue</code> 等其他方法。</p>
<p> <code>Dispatch Source</code> 与 <code>Dispatch Queue</code> 不同，是可以取消的。而且取消时必须执行的处理可指定为回调用的Block形式。</p>
<p> <code>Dispatch Source</code>  是如何执行取消的？打个比方：</p>
<p> <code>Dispatch Queue</code> 就好像瓜农种瓜，只要种了瓜，就走上了一条不归路：不管有没有人买，你都必须要好好施肥，好好浇水。没有放弃的余地。</p>
<p> <code>Dispatch Source</code> 就好像买瓜的人，比如你在瓜农种瓜时，告诉瓜农，“你的瓜熟一个我买一个”，等瓜成熟了，你开始买，不断得买，陆续买了100个，突然你感觉吃够了，你不买了，但是瓜还是在不断得成熟着，然后只能烂在地里了。等你突然又想买的时候，地里已经有1000个瓜，你要买，必须全买。。。</p>
<p> 回到代码里，也就是说 <code>Dispatch Source</code> 的暂停，只是暂停调用 <code>dispatch_source_set_event_handler</code> ， <code>Dispatch Queue</code> 中的for循环并没有因此暂停，它还是在一直运行着，等你恢复 <code>Dispatch Source</code> 的时候， <code>Dispatch Queue</code> 可能已经运行结束。然后你就会像上面的gif图中那样，从“进度：0.9”暂停，恢复时直接跳到“进度：1”，跳过了中间的“进度：0.91”、“进度：0.92”、“进度：0.93”等等。所以说这是一种“假暂停”。</p>
<p> 那么如何在处理中导入取消这一概念？代码如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">__block BOOL isCanceled = NO;</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">if (isCanceled) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSData *thumbnailData = [NSURLConnection sendSynchronousRequest:request];</span><br><span class="line">...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p> 完整的代码则需要做如下修改：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">//1.</span><br><span class="line">// 指定DISPATCH_SOURCE_TYPE_DATA_ADD，做成Dispatch Source(分派源)。设定Main Dispatch Queue 为追加处理的Dispatch Queue</span><br><span class="line">_processingQueueSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0,</span><br><span class="line">dispatch_get_main_queue());</span><br><span class="line">__block NSUInteger totalComplete = 0;</span><br><span class="line">dispatch_source_set_event_handler(_processingQueueSource, ^&#123;</span><br><span class="line">//当处理事件被最终执行时，计算后的数据可以通过dispatch_source_get_data来获取。这个数据的值在每次响应事件执行后会被重置，所以totalComplete的值是最终累积的值。</span><br><span class="line">NSUInteger value = dispatch_source_get_data(_processingQueueSource);</span><br><span class="line">totalComplete += value;</span><br><span class="line">NSLog(@&quot;进度：%@&quot;, @((CGFloat)totalComplete/CYLTotalNumber));</span><br><span class="line">&#125;);</span><br><span class="line">//分派源创建时默认处于暂停状态，在分派源分派处理程序之前必须先恢复。</span><br><span class="line">[self resume];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//2.</span><br><span class="line">//恢复源后，就可以通过dispatch_source_merge_data向Dispatch Source(分派源)发送事件:</span><br><span class="line">//为了便于观察，将_queue做成“串行队列”</span><br><span class="line">_queue = dispatch_queue_create(&quot;com.ioschengxuyuan.queue1&quot;, 0);</span><br><span class="line">NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, @&quot;启动队列&quot;);</span><br><span class="line">for (NSUInteger index = 0; index &lt; CYLTotalNumber; index++) &#123;</span><br><span class="line">dispatch_async(_queue, ^&#123;</span><br><span class="line">if (!self.running) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">dispatch_source_merge_data(_processingQueueSource, 1);</span><br><span class="line">usleep(200000);//0.2秒</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">[super didReceiveMemoryWarning];</span><br><span class="line">[self changeStatus:self.running];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)changeStatus:(BOOL)shouldPause &#123;</span><br><span class="line">if (shouldPause) &#123;</span><br><span class="line">[self pause];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">[self resume];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)resume &#123;</span><br><span class="line">if (self.running) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;✅恢复Dispatch Source(分派源)以及_queue&quot;);</span><br><span class="line">self.running = YES;</span><br><span class="line">dispatch_resume(_processingQueueSource);</span><br><span class="line">if (_queue) &#123;</span><br><span class="line">dispatch_resume(_queue);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)pause &#123;</span><br><span class="line">if (!self.running) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;🚫暂停Dispatch Source(分派源)以及_queue&quot;);</span><br><span class="line">self.running = NO;</span><br><span class="line">dispatch_suspend(_processingQueueSource);</span><br><span class="line">dispatch_suspend(_queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <img src="http://i61.tinypic.com/33m06er.jpg" alt="enter image description here"></p>
<p> 详见 Demo4（Demo_04_对DispatchQueue实现取消恢复操作_综合版）</p>
<h2 id="Parse-“离线存储对象”操作的代码摘录"><a href="#Parse-“离线存储对象”操作的代码摘录" class="headerlink" title="Parse “离线存储对象”操作的代码摘录"></a>Parse “离线存储对象”操作的代码摘录</h2><p> 句柄如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_set_event_handler(_processingQueueSource, ^&#123;</span><br><span class="line">[self _runCommands];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p> 何时会调用句柄？ 下面将 Parse 里涉及调用句柄的语句罗列一下， 因为摘录的代码不完整，可能并不能看出使用的完整过程。所以可以大致预览一下，详情可以查看Parse 源码，并且我已将这些逻辑浓缩为可运行的 Demo，也可搭配理解。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)start &#123;</span><br><span class="line">dispatch_source_set_event_handler(_processingQueueSource, ^&#123;</span><br><span class="line">[self _runCommands];</span><br><span class="line">&#125;);</span><br><span class="line">[self resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)resume &#123;</span><br><span class="line">if (self.running) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">self.running = YES;</span><br><span class="line">dispatch_resume(_processingQueueSource);</span><br><span class="line">dispatch_source_merge_data(_processingQueueSource, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 监听网络状态，一旦网络重连上之后，设置 connected属性为 YES，并重写其 setter 方法，调用 <code>dispatch_source_merge_data</code> 进行发送消息的操作：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*! Manually sets the network connection status. */</span><br><span class="line">- (void)setConnected:(BOOL)connected &#123;</span><br><span class="line">BFTaskCompletionSource *barrier = [BFTaskCompletionSource taskCompletionSource];</span><br><span class="line">dispatch_async(_processingQueue, ^&#123;</span><br><span class="line">dispatch_sync(_synchronizationQueue, ^&#123;</span><br><span class="line">if (self.connected != connected) &#123;</span><br><span class="line">_connected = connected;</span><br><span class="line">if (connected) &#123;</span><br><span class="line">dispatch_source_merge_data(_processingQueueSource, 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">barrier.result = nil;</span><br><span class="line">&#125;);</span><br><span class="line">if (connected) &#123;</span><br><span class="line">dispatch_async(_synchronizationQueue, ^&#123;</span><br><span class="line">if (_retryingSemaphore) &#123;</span><br><span class="line">dispatch_semaphore_signal(_retryingSemaphore);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">[barrier.task waitForResult:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)_didEnqueueCommand:(id&lt;PFNetworkCommand&gt;)command</span><br><span class="line">withIdentifier:(NSString *)identifier</span><br><span class="line">taskCompletionSource:(BFTaskCompletionSource *)taskCompletionSource &#123;</span><br><span class="line">PFAssertIsOnDispatchQueue(_synchronizationQueue);</span><br><span class="line"></span><br><span class="line">_taskCompletionSources[identifier] = taskCompletionSource;</span><br><span class="line">dispatch_source_merge_data(_processingQueueSource, 1);</span><br><span class="line"></span><br><span class="line">if (_retryingSemaphore) &#123;</span><br><span class="line">dispatch_semaphore_signal(_retryingSemaphore);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Dispatch-Semaphore-信号量"><a href="#Dispatch-Semaphore-信号量" class="headerlink" title="Dispatch Semaphore 信号量"></a><code>Dispatch Semaphore</code> 信号量</h2><p> 为了展示作用，举个反例：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">NSMutableArray *array = [[NSMutableArray alloc] init];</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">for(int i = 0; i&lt; 100000; ++i) &#123;</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">[array addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">NSLog(@&quot;%@&quot;,  @([array count]));</span><br></pre></td></tr></table></figure>
<p> 运行结果绝对大跌眼镜：</p>
<p> 我运行了三次，三次结果均不一致：</p>
<ol>
<li><p>第一次：崩溃。。。</p>
<p><img src="http://i67.tinypic.com/29vxt9w.jpg" alt="enter image description here"></p>
</li>
</ol>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CYLDispatchSemaphoreTest(10384,0x112d43000) malloc: *** error for object 0x7f898487ca00: pointer being freed was not allocated</span><br><span class="line">*** set a breakpoint in malloc_error_break to debug</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>第二次：不够。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2015-09-07 00:42:20.145 CYLDispatchSemaphoreTest[10417:779722] 99996</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li>第三次：还是不够。。。</li>
</ol>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2015-09-07 00:42:52.734 CYLDispatchSemaphoreTest[10438:780505] 99949</span><br></pre></td></tr></table></figure>
<p> 这种资源抢夺的情况，一般的做法是使用串行队列，或者像下面一样的同步队列，得以解决：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">NSMutableArray *array = [[NSMutableArray alloc] init];</span><br><span class="line">for(int i = 0; i&lt; 100000; ++i) &#123;</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">[array addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;%@&quot;, @([array count]));</span><br></pre></td></tr></table></figure>
<p> 下面展示下展示使用 <code>dispatch_semaphore_t</code> 的解决方案：</p>
<p> <code>dispatch_semaphore_t</code> 的作用之一就是解决这种资源抢夺的情况，下面展示下使用 <code>dispatch_semaphore_t</code> 实现一个资源锁：</p>
<p> 以下源码详见 Demo6（Demo_06_展示dispatch_semaphore_t基本用法）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">//因为用到了dispatch_barrier_async，该函数只能搭配自定义并行队列dispatch_queue_t使用。所以不能使用：dispatch_get_global_queue</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.ioschengxuyuan.gcd.ForBarrier&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">/*</span><br><span class="line">*</span><br><span class="line">*生成Dispatch Semaphore</span><br><span class="line">Dispatch Semaphore 的计数初始值设定为“1”</span><br><span class="line">(该初始值的1与下文中两个函数dispatch_semaphore_wait与dispatch_semaphore_signal进行的减1、加1里的1没有必然联系。</span><br><span class="line"></span><br><span class="line">就算初始值是100，两个函数dispatch_semaphore_wait与dispatch_semaphore_signal还是会减“1”、加“1”)。</span><br><span class="line">保证可访问 NSMutableArray 类对象的线程</span><br><span class="line">同时只能有1个</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(1) ;</span><br><span class="line">NSMutableArray *array = [[NSMutableArray alloc] init];</span><br><span class="line">for(int i = 0; i&lt; 100000; ++i) &#123;</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">/*</span><br><span class="line">*</span><br><span class="line">*等待Dispatch Semaphore</span><br><span class="line">*一直等待，直到Dispatch Semaphore的计数值达到大于等于1</span><br><span class="line">*/</span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER) ;</span><br><span class="line">/*</span><br><span class="line">*由于Dispatch Semaphore的计数值达到大于等于1</span><br><span class="line">*所以将Dispatch Semaphore的计数值减去1</span><br><span class="line">*dispatch_semaphore_wait 函数执行返回。</span><br><span class="line">*即执行到此时的</span><br><span class="line">*Dispatch Semaphore 的计数值恒为0</span><br><span class="line">*</span><br><span class="line">*由于可访问NSMutaleArray类对象的线程</span><br><span class="line">*只有一个</span><br><span class="line">*因此可安全地进行更新</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">NSLog(@&quot;🔴%@&quot;,[NSThread currentThread]);</span><br><span class="line">[array addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">/*</span><br><span class="line">*</span><br><span class="line">*排他控制处理结束，</span><br><span class="line">*所以通过dispatch_semaphore_signal函数</span><br><span class="line">*将Dispatch Semaphore的计数值加1</span><br><span class="line">*如果有通过dispatch_semaphore_wait函数</span><br><span class="line">*等待Dispatch Semaphore的计数值增加的线程，</span><br><span class="line">★就由最先等待的线程执行。</span><br><span class="line">*/</span><br><span class="line">dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">*</span><br><span class="line">等为数组遍历添加元素后，检查下数组的成员个数是否正确</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, @([array count]));</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 为了加深对dispatch_semaphore_t基本用法的理解，再给一个示例 Demo：</p>
<p> 思考下为何会如何打印：<br> 然后再分别试一下第三行和第四行：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">//    dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</span><br></pre></td></tr></table></figure>
<p> 然后观察下打印。</p>
<p> 详见 Demo5（Demo_05_展示dispatch_semaphore_t基本用法）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">//    dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</span><br><span class="line"></span><br><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 1ull * NSEC_PER_SEC);//等待一秒</span><br><span class="line">//dispatch_time_t time = DISPATCH_TIME_FOREVER;//永久等待</span><br><span class="line">NSLog(@&quot;begin ==&gt;  车库开始营业了！&quot;);</span><br><span class="line">/*</span><br><span class="line">*</span><br><span class="line">如果 semphore 的值等于0，就阻塞1秒钟，才会往下照常进行；</span><br><span class="line">如果大于等于1则往下进行并将 semphore 进行减1处理。</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">long result = dispatch_semaphore_wait(semaphore, time);</span><br><span class="line">if (result == 0) &#123;</span><br><span class="line">/*</span><br><span class="line">*</span><br><span class="line">*由子Dispatch Semaphore的计数值达到大于等于1</span><br><span class="line">*或者在待机中的指定时间内</span><br><span class="line">*Dispatch Semaphore的计数值达到大于等于1</span><br><span class="line">所以Dispatch Semaphore的计数值减去1</span><br><span class="line">可执行需要进行排他控制的处理.</span><br><span class="line">可以理解为：没有阻塞的线程了。</span><br><span class="line">就好比：车库有一个或一个以上的车位，只来了一辆车，所以“无需等待”</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">NSLog(@&quot;result = 0 ==&gt; 有车位，无需等待！==&gt; 在这里可安全地执行【需要排他控制的处理（比如只允许一条线程为mutableArray进行addObj操作）】&quot;);</span><br><span class="line">dispatch_semaphore_signal(semaphore);//使用signal以确保编译器release掉dispatch_semaphore_t时的值与初始值一致， 否则会EXC_BAD_INSTRUCTION ,见http://is.gd/EaJgk5</span><br><span class="line">&#125; else &#123;</span><br><span class="line">/*</span><br><span class="line">*</span><br><span class="line">*由于Dispatch Semaphore的计数值为0</span><br><span class="line">.因此在达到指定时间为止待机</span><br><span class="line">这个else里发生的事情，就好比：车库没车位，来了一辆车，等待了半个小时后，做出的一些事情。</span><br><span class="line">比如：忍受不了，走了。。</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">NSLog(@&quot;result != 0 ==&gt; timeout，deadline，忍受不了，走了。。&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在项目中的应用：强制把异步任务转换为同步任务来方便进行单元测试"><a href="#在项目中的应用：强制把异步任务转换为同步任务来方便进行单元测试" class="headerlink" title="在项目中的应用：强制把异步任务转换为同步任务来方便进行单元测试"></a>在项目中的应用：强制把异步任务转换为同步任务来方便进行单元测试</h3><p> 下面是 Parse 的一段代码：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface PFEventuallyQueueTestHelper : NSObject &#123;</span><br><span class="line">dispatch_semaphore_t events[PFEventuallyQueueEventCount];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)clear;</span><br><span class="line">- (void)notify:(PFEventuallyQueueTestHelperEvent)event;</span><br><span class="line">- (BOOL)waitFor:(PFEventuallyQueueTestHelperEvent)event;</span><br></pre></td></tr></table></figure>
<p> 注释是这样写的：</p>
<blockquote>
<p>PFEventuallyQueueTestHelper gets notifications of various events happening in the command cache,<br> // so that tests can be synchronized. See CommandTests.m for examples of how to use this.</p>
</blockquote>
<p> 强制把异步任务转换为同步任务来方便进行单元测试。这个用途信号量是最合适的用途。但注意并不推荐应用到除此之外的其它场景！</p>
<p> 这种异步转同步便于单元测试的用法类似于下面的写法：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define WAIT_FOREVER [self waitForStatus:XCTAsyncTestCaseStatusSucceeded timeout:DBL_MAX];</span><br><span class="line">#define NOTIFY [self notify:XCTAsyncTestCaseStatusSucceeded];</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)testInstallationMutated &#123;</span><br><span class="line">NSDictionary *dict = [self jsonWithFileName:@&quot;TestInstallationSave&quot;];</span><br><span class="line">AVInstallation *installation = [AVInstallation currentInstallation];</span><br><span class="line">[installation objectFromDictionary:dict];</span><br><span class="line">[installation setObject:@(YES) forKey:@&quot;enableNoDisturb&quot;];</span><br><span class="line">[installation saveInBackgroundWithBlock:^(BOOL succeeded, NSError *error) &#123;</span><br><span class="line">XCTAssertNil(error);</span><br><span class="line">NOTIFY;</span><br><span class="line">&#125;];</span><br><span class="line">WAIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 信号量属性底层工具，他虽然非常强大，但在多数需要使用它的场合，最好从设计角度重新考虑，看是否可以不用，应该优先考虑使用诸如操作队列这样的高级工具。通常可以通过增加一个分派队列配合  <code>dispatch_suspend</code> ，或者通过其它方式分解操作来避免使用信号量。信号量并非不好，只是它本身是锁，能不使用就不用。尽量用 cocoa 框架中的高级抽象，信号量非常接近底层。所以除了上面的例子是最佳应用场景外，不推荐应用到除此之外的其它场景！</p>
<p> <a href="http://www.cnblogs.com/snailHL/p/3906112.html" target="_blank" rel="noopener">《关于dispatch_semaphore的使用》</a> 中有这样的描述：</p>
<p> 关于信号量，一般可以用停车来比喻。</p>
<blockquote>
<p>　　停车场剩余4个车位，那么即使同时来了四辆车也能停的下。如果此时来了五辆车，那么就有一辆需要等待。</p>
</blockquote>
<blockquote>
<p>　　信号量的值就相当于剩余车位的数目，dispatch_semaphore_wait函数就相当于来了一辆车，</p>
</blockquote>
<blockquote>
<p>　　dispatch_semaphore_signal，就相当于走了一辆车。停车位的剩余数目在初始化的时候就已经指明了（dispatch_semaphore_create（long value））</p>
</blockquote>
<blockquote>
<p>　　调用一次dispatch_semaphore_signal，剩余的车位就增加一个；调用一次dispatch_semaphore_wait剩余车位就减少一个；</p>
</blockquote>
<blockquote>
<p>　　当剩余车位为0时，再来车（即调用dispatch_semaphore_wait）就只能等待。有可能同时有几辆车等待一个停车位。有些车主</p>
</blockquote>
<blockquote>
<p>　　没有耐心，给自己设定了一段等待时间，这段时间内等不到停车位就走了，如果等到了就开进去停车。而有些车主就像把车停在这，</p>
</blockquote>
<blockquote>
<p>　　所以就一直等下去。</p>
</blockquote>
<p> <a href="http://m.blog.csdn.net/blog/choudang/38121827" target="_blank" rel="noopener">《GCD dispatch_semaphore 信号量 协调线程同步》</a> 也有类似的比喻：</p>
<blockquote>
<p>以一个停车场是运作为例。为了简单起见，假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了五辆车，看门人允许其中三辆不受阻碍的进入，然后放下车拦，剩下的车则必须在入口等待，此后来的车也都不得不在入口处等待。这时，有一辆车离开停车场，看门人得知后，打开车拦，放入一辆，如果又离开两辆，则又可以放入两辆，如此往复。<br> </p> 在这个停车场系统中，车位是公共资源，每辆车好比一个线程，看门人起的就是信号量的作用。<br> 更进一步，信号量的特性如下：信号量是一个非负整数（车位数），所有通过它的线程（车辆）都会将该整数减一（通过它当然是为了使用资源），当该整数值为零时，所有试图通过它的线程都将处于等待状态。在信号量上我们定义两种操作： Wait（等待） 和 Release（释放）。 当一个线程调用Wait（等待）操作时，它要么通过然后将信号量减一，要么一直等下去，直到信号量大于一或超时。Release（释放）实际上是在信号量上执行加操作，对应于车辆离开停车场，该操作之所以叫做“释放”是因为加操作实际上是释放了由信号量守护的资源。<p></p>
</blockquote>
<p> 这个比喻里可以用一个表格来表示：</p>
<table>
<thead>
<tr>
<th>喻体</th>
<th>本体</th>
<th>代码</th>
</tr>
</thead>
<tbody>
<tr>
<td> 车位</td>
<td>信号量</td>
<td><code>dispatch_semaphore_t</code>  </td>
</tr>
<tr>
<td> 剩余几个车位</td>
<td>最大并发线程</td>
<td><code>dispatch_semaphore_t</code>  </td>
</tr>
<tr>
<td> 看门人起的作用</td>
<td>信号量的作用</td>
<td><code>dispatch_semaphore_t</code>  </td>
</tr>
<tr>
<td> 车</td>
<td>线程</td>
<td>代码 </td>
</tr>
<tr>
<td> 耐心的极限时间</td>
<td>超时时间</td>
<td><code>dispatch_semaphore_wait</code>  </td>
</tr>
<tr>
<td> 逛街结束走了，离开车位</td>
<td>signal+1</td>
<td><code>dispatch_semaphore_signal</code>  </td>
</tr>
</tbody>
</table>
<h3 id="使用Dispatch-Semaphore控制并发线程数量"><a href="#使用Dispatch-Semaphore控制并发线程数量" class="headerlink" title="使用Dispatch Semaphore控制并发线程数量"></a>使用<code>Dispatch Semaphore</code>控制并发线程数量</h3><p> 正如文章开头所说：从 iOS7 升到 iOS8 后，GCD 出现了一个重大的变化：在 iOS7 时，使用 GCD 的并行队列，  <code>dispatch_async</code>  最大开启的线程一直能控制在6、7条，线程数都是个位数，然而 iOS8后，最大线程数一度可以达到40条、50条。然而在文档上并没有对这一做法的目的进行介绍。</p>
<p> 笔者推测 Apple 的目的是想借此让开发者使用 <code>NSOperationQueue</code> ：GCD 中 Apple 并没有提供控制并发数量的接口，而  <code>NSOperationQueue</code>  有，如果需要使用 GCD 实现，需要使用 GCD 的一项高级功能：<code>Dispatch Semaphore</code>信号量。</p>
<p> 详见 Demo7（Demo_07_展示dispatch_semaphore_t控制线程并发数量的用法）</p>
<p> Demo7中使用了 <a href="http://mp.weixin.qq.com/s?__biz=MzAxNDAzMzk0MQ==&amp;mid=203702345&amp;idx=1&amp;sn=226f6f784d37b89718f6949c9214e1e6&amp;scene=1&amp;srcid=kl2ZmcSfYHuB6bMvYPEq#rd" target="_blank" rel="noopener">这篇博文</a> 中的例子。</p>
<p> <code>Dispatch Semaphore</code>信号量的使用在上文中已经介绍过，那么就直接上 Demo：</p>
<p> 主要做的就是将上文中 <code>dispatch_semaphore_t</code> 的个数设置为一个可变参数：这样就达到了控制并行线程数量的目的：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*</span><br><span class="line">简单版本：无专门控制并发等待的线程，缺点阻塞主线程，可以跑一下 demo，你会发现主屏幕上的按钮是不可点击的</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">void dispatch_async_limit(dispatch_queue_t queue,NSUInteger limitSemaphoreCount, dispatch_block_t block) &#123;</span><br><span class="line">//控制并发数的信号量</span><br><span class="line">static dispatch_semaphore_t limitSemaphore;</span><br><span class="line">//专门控制并发等待的线程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用 dispatch_once而非 lazy 模式，防止可能的多线程抢占问题</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">limitSemaphore = dispatch_semaphore_create(limitSemaphoreCount);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//可用信号量后才能继续，否则等待</span><br><span class="line">dispatch_semaphore_wait(limitSemaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">!block ? : block();</span><br><span class="line">//在该工作线程执行完成后释放信号量</span><br><span class="line">dispatch_semaphore_signal(limitSemaphore);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 你可能发现，这段代码有问题阻塞了当前线程，Demo7中也给出了改良版，可以看下。</p>
<h3 id="为-NSURLSession-添加同步方法"><a href="#为-NSURLSession-添加同步方法" class="headerlink" title="为  NSURLSession 添加同步方法"></a>为  NSURLSession 添加同步方法</h3><p> NSURLSession 取消了同步方法，但是可以借助信号量来实现：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ (NSData *)sendSynchronousRequest:(NSURLRequest *)request returningResponse:(NSURLResponse *__autoreleasing *)response error:(NSError *__autoreleasing *)error &#123;</span><br><span class="line">__block NSData *data = nil;</span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line"></span><br><span class="line">[[[NSURLSession sharedSession] dataTaskWithRequest:request completionHandler:^(NSData *taskData, NSURLResponse *taskResponse, NSError *taskError) &#123;</span><br><span class="line">data = taskData;</span><br><span class="line"></span><br><span class="line">if (response)</span><br><span class="line">*response = taskResponse;</span><br><span class="line"></span><br><span class="line">if (error)</span><br><span class="line">*error = taskError;</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;] resume];</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 但是也要思考下为什么 Apple 取消了同步方法：同步方法的风险远远超过受益。</p>
<p> 要注意：</p>
<ul>
<li>除非万不得已，否则永远不要尝试在主线程上发送同步的网络请求</li>
<li>尽量只在后台线程中独占线程发送同步的网络请求</li>
</ul>
<p> 风险如下所示：</p>
<h4 id="导致Watchdog超时"><a href="#导致Watchdog超时" class="headerlink" title="导致Watchdog超时"></a>导致Watchdog超时</h4><p> 关于Watchdog超时：</p>
<p> 在  <a href="https://developer.apple.com/library/ios/qa/qa1693/_index.html" target="_blank" rel="noopener"> <strong><em>QA1693：Synchronous Networking On The Main Thread</em></strong> </a><br> 文档中描述了Watchdog机制，包括生效场景和表现。如果我们的应用程序对一些特定的UI事件（比如启动、挂起、恢复、结束）响应不及时，Watchdog会把我们的应用程序干掉，并生成一份响应的crash报告。</p>
<p> 这份crash报告的有趣之处在于异常代码：“0x8badf00d”，即“ate bad food”。<br> 如果说特定的UI事件比较抽象，那么用代码来直接描述的话，对应的就是（创建一个工程时Xcode自动生成的）UIApplicationDelegate的几个方法：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationWillResignActive:(UIApplication *)application &#123;</span><br><span class="line">// Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.</span><br><span class="line">// Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application &#123;</span><br><span class="line">// Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.</span><br><span class="line">// If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationWillEnterForeground:(UIApplication *)application &#123;</span><br><span class="line">// Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationDidBecomeActive:(UIApplication *)application &#123;</span><br><span class="line">// Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationWillTerminate:(UIApplication *)application &#123;</span><br><span class="line">// Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 所以当遇到Watchdog日志时，可以检查下上面几个方法是否有比较重的阻塞UI的动作。</p>
<p> <a href="https://developer.apple.com/library/ios/qa/qa1693/_index.html" target="_blank" rel="noopener"> <strong><em>QA1693：Synchronous Networking On The Main Thread</em></strong> </a> 举的例子就是在主线程进行同步网络请求。如果我们是在公司的Wifi环境下使用则一切顺利，但当应用程序发布出去面向很大范围的用户，在各种网络环境下运行，则不可避免地会出现一片Watchdog超时报告。<br> 另一种可能出现问题的场景就是数据量比较大的情况下进行的数据库版本迁移（同样是在主线程上）。</p>
<h4 id="失去了-cancel-的机会："><a href="#失去了-cancel-的机会：" class="headerlink" title="失去了 cancel 的机会："></a>失去了 cancel 的机会：</h4><p> 不能像异步那样进行下面的操作：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(IBAction)cancelUpload:(id)sender &#123;</span><br><span class="line">if (_uploadTask.state == NSURLSessionTaskStateRunning) &#123;</span><br><span class="line">[_uploadTask cancel];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <a href="http://blog.csdn.net/jasonblog/article/details/19031517" target="_blank" rel="noopener">《iOS应用的crash日志的分析基础》</a> </p>
<p> 参考链接： <a href="https://github.com/ParsePlatform/Parse-SDK-iOS-OSX" target="_blank" rel="noopener">GitHub:Parse-SDK-iOS-OSX源码</a> </p>
<hr>
<p> <a href="https://github.com/ChenYilong/ParseSourceCodeStudy" target="_blank" rel="noopener">转载：微博@iOS程序犭袁：GCD高级用法</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/26/9-6多线程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NSLegend">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/26/9-6多线程/" itemprop="url">9.6多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-26T10:36:10+08:00">
                2018-12-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS底层/" itemprop="url" rel="index">
                    <span itemprop="name">iOS底层</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="iOS线程死锁"><a href="#iOS线程死锁" class="headerlink" title="iOS线程死锁"></a>iOS线程死锁</h2><p><strong>结论：使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）</strong></p>
<p>首先你要理解同步和异步执行的概念，同步和异步目的不是为了是否创建一个新的线程，同步会阻塞当前函数的返回，异步函数会立即返回执行下面的代码；队列是一种数据结构，队列有FIFO,LIFO等，控制任务的执行顺序，至于是否开辟一个新的线程，因为同步函数会等待函数的返回，所以在当前线程执行就行了，没必要浪费资源再开辟新的线程，如果是异步函数，当前线程需要立即函数返回，然后往下执行，所以函数里面的任务必须要开辟一个新的线程去执行这个任务。</p>
<p><code>队列上是放任务的,而线程是去执行队列上的任务的</code></p>
<p>【问题1】：以下代码是在主线程执行的，会不会产生死锁？会！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;执行任务1&quot;);</span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">NSLog(@&quot;执行任务2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;执行任务3&quot;);</span><br></pre></td></tr></table></figure></p>

<p><code>dispatch_sync立马在当前线程同步执行任务</code></p>
<p>分析：</p>
<ul>
<li>1、主线程中任务执行：<code>任务1</code>、<code>sync</code>、<code>任务3</code>、</li>
<li>2、主队列：<code>viewDidLoad</code>、<code>任务2</code>、</li>
</ul>
<p>其中在主队列<code>viewDidLoad</code>里面的<code>任务3</code>执行结束才会执行<code>任务2</code>；而主线程中是执行完<code>sync</code>才会执行<code>任务3</code>。也就是<code>任务2</code>等待<code>任务3</code>执行，<code>任务3</code>再也等待<code>任务2</code>执行，造成死锁</p>

<p>【问题2】：以下代码是在主线程执行的，会不会产生死锁？不会！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)interview02</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;执行任务1&quot;);</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">NSLog(@&quot;执行任务2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;执行任务3&quot;);</span><br><span class="line"></span><br><span class="line">// dispatch_async不要求立马在当前线程同步执行任务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为<code>dispatch_async</code>不要求立马在当前线程同步执行任务，不会造成线程死锁</p>
<p>【问题3】：以下代码是在主线程执行的，会不会产生死锁？会！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;执行任务1&quot;);</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;myqueu&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_async(queue, ^&#123; // 0</span><br><span class="line">NSLog(@&quot;执行任务2&quot;);</span><br><span class="line"></span><br><span class="line">dispatch_sync(queue, ^&#123; // 1</span><br><span class="line">NSLog(@&quot;执行任务3&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;执行任务4&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;执行任务5&quot;);</span><br></pre></td></tr></table></figure>

<p>其中<code>执行任务3</code>和<code>执行任务4</code>之间造成死锁</p>
<p>【问题4】：以下代码是在主线程执行的，会不会产生死锁？不会！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)interview04</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;执行任务1&quot;);</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;myqueu&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123; // 0</span><br><span class="line">NSLog(@&quot;执行任务2&quot;);</span><br><span class="line"></span><br><span class="line">dispatch_sync(queue, ^&#123; // 1</span><br><span class="line">NSLog(@&quot;执行任务3&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;执行任务4&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;执行任务5&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/26/9-5多线程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NSLegend">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/26/9-5多线程/" itemprop="url">9.5多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-26T10:36:03+08:00">
                2018-12-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS底层/" itemprop="url" rel="index">
                    <span itemprop="name">iOS底层</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><ul>
<li>1、为什么要线程安全 </li>
<li>2、自旋锁和互斥锁</li>
<li>3、锁的类型<br>  -1、OSSpinLock<ul>
<li>2、os_unfair_lock</li>
<li>3、pthread_mutex</li>
<li>4、dispatch_semaphore</li>
<li>5、dispatch_queue(DISPATCH_QUEUE_SERIAL)</li>
<li>6、NSLock</li>
<li>7、NSRecursiveLock</li>
<li>8、NSCondition</li>
<li>9、NSConditionLock</li>
<li>10、@synchronized</li>
<li>11、pthread_rwlock</li>
<li>12、dispatch_barrier_async</li>
<li>13、atomic</li>
</ul>
</li>
<li>4、锁的性能比较</li>
</ul>
<h3 id="为什么要线程安全"><a href="#为什么要线程安全" class="headerlink" title="为什么要线程安全"></a>为什么要线程安全</h3><p>多个线程访问同一块资源的时候，很容易引发数据混乱问题。<br>一个大家都喜欢拿来举例子的就是<code>买票demo</code>，今天我使用这个案例<br><code>假设有100张票，同时开5个窗口买票，5个窗口买票，我们来看看结果</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//卖票演示</span><br><span class="line">- (void)ticketTest&#123;</span><br><span class="line">self.ticketsCount = 50;</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line"></span><br><span class="line">for (NSInteger i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">[self sellingTickets];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//卖票</span><br><span class="line">- (void)sellingTickets&#123;</span><br><span class="line">int oldMoney = self.ticketsCount;</span><br><span class="line">sleep(.2);</span><br><span class="line">oldMoney -= 1;</span><br><span class="line">self.ticketsCount = oldMoney;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;当前剩余票数-&gt; %d&quot;, oldMoney);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2018/12/26/9-5多线程/线程安全1.png" title="线程安全1">
<p>正常情况下我有50张票，然后卖了50次，剩余票数应该是0，但是打印结果竟然是3，所以这里就存在了线程安全问题。</p>
<p><strong>出现线程安全的原因</strong></p>
<img src="/2018/12/26/9-5多线程/线程安全2.png" title="线程安全2">
<p>出现线程安全的原因就是在同一个时间，多个线程同时读取一个值，像线程A和B同时读取了当前票数为10，等于是卖了两张票，但是总票数其实就减少了一张。</p>
<p><strong>解决方法</strong></p>
<p>使用线程同步技术，按照预定的先后次序依次进行，常见的线程同步技术就是<code>加锁</code></p>
<img src="/2018/12/26/9-5多线程/线程安全3.png" title="线程安全3">
<h3 id="自旋锁和互斥锁"><a href="#自旋锁和互斥锁" class="headerlink" title="自旋锁和互斥锁"></a>自旋锁和互斥锁</h3><p><strong>自旋锁(Spin lock)</strong></p>
<p>自旋锁与互斥锁有点类似，只是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是 否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。其作用是为了解决某项资源的互斥使用。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远 高于互斥锁。虽然它的效率比互斥锁高，但是它也有些不足之处：<br>    1、自旋锁一直占用CPU，他在未获得锁的情况下，一直运行－－自旋，所以占用着CPU，如果不能在很短的时 间内获得锁，这无疑会使CPU效率降低。<br>    2、在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁，调用有些其他函数也可能造成死锁，如 copy_to_user()、copy_from_user()、kmalloc()等。<br>    因此我们要慎重使用自旋锁，自旋锁只有在内核可抢占式或SMP的情况下才真正需要，在单CPU且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁时间比较短的情况下。</p>
<p><strong>互斥锁</strong></p>
<p>互斥锁属于sleep-waiting类型的锁。例如在一个双核的机器上有两个线程(线程A和线程B)，它们分别运行在Core0和 Core1上。假设线程A想要通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞 (blocking)，Core0 会在此时进行上下文切换(Context Switch)将线程A置于等待队列中，此时Core0就可以运行其他的任务(例如另一个线程C)而不必进行忙等待。而自旋锁则不然，它属于busy-waiting类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，那么线程A就会一直在 Core0上进行忙等待并不停的进行锁请求，直到得到这个锁为止。</p>
<p><strong>两种锁的加锁原理</strong></p>
<p>互斥锁：线程会从sleep（加锁）——&gt;running（解锁），过程中有上下文的切换，cpu的抢占，信号的发送等开销。</p>
<p>自旋锁：线程一直是running(加锁——&gt;解锁)，死循环检测锁的标志位，机制不复杂。</p>
<p><strong>对比</strong><br>互斥锁的起始原始开销要高于自旋锁，但是基本是一劳永逸，临界区持锁时间的大小并不会对互斥锁的开销造成影响，而自旋锁是死循环检测，加锁全程消耗cpu，起始开销虽然低于互斥锁，但是随着持锁时间，加锁的开销是线性增长。</p>
<p><strong>两种锁的应用</strong></p>
<p>互斥锁用于临界区持锁时间比较长的操作，比如下面这些情况都可以考虑</p>
<ul>
<li>1 临界区有IO操作</li>
<li>2 临界区代码复杂或者循环量大</li>
<li>3 临界区竞争非常激烈</li>
<li>4 单核处理器</li>
</ul>
<p>至于自旋锁就主要用在临界区持锁时间非常短且CPU资源不紧张的情况下，自旋锁一般用于多核的服务器。</p>
<h3 id="13种锁"><a href="#13种锁" class="headerlink" title="13种锁"></a>13种锁</h3><h4 id="1、OSSpinLock"><a href="#1、OSSpinLock" class="headerlink" title="1、OSSpinLock"></a>1、OSSpinLock</h4><p>OSSpinLock叫做”自旋锁”，使用时需要导入头文件#import &lt;libkern/OSAtomic.h&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//初始化</span><br><span class="line">OSSpinLock lock = OS_SPINLOCK_INIT;</span><br><span class="line">//加锁</span><br><span class="line">OSSpinLockLock(&amp;lock);</span><br><span class="line">//解锁</span><br><span class="line">OSSpinLockUnlock(&amp;lock);</span><br></pre></td></tr></table></figure>
<p><strong>demo</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;OSSpinLockDemo.h&quot;</span><br><span class="line">#import &lt;libkern/OSAtomic.h&gt;</span><br><span class="line">@interface OSSpinLockDemo()</span><br><span class="line">@property (assign, nonatomic) OSSpinLock ticketLock;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation OSSpinLockDemo</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">self = [super init];</span><br><span class="line">if (self) &#123;</span><br><span class="line">self.ticketLock = OS_SPINLOCK_INIT;</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//卖票</span><br><span class="line">- (void)sellingTickets&#123;</span><br><span class="line">OSSpinLockLock(&amp;_ticketLock);</span><br><span class="line"></span><br><span class="line">[super sellingTickets];</span><br><span class="line"></span><br><span class="line">OSSpinLockUnlock(&amp;_ticketLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<img src="/2018/12/26/9-5多线程/线程安全4.png" title="线程安全4">
<p><code>OSSpinLock</code>在iOS10.0以后就被弃用了，可以使用<code>os_unfair_lock_lock</code>替代。而且还有一些安全性问题，具体参考<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a></p>
<h4 id="2、os-unfair-lock"><a href="#2、os-unfair-lock" class="headerlink" title="2、os_unfair_lock"></a>2、os_unfair_lock</h4><p><code>os_unfair_lock</code>用于取代不安全的<code>OSSpinLock</code>，从iOS10开始才支持<br>从底层调用看，等待os_unfair_lock锁的线程会处于休眠状态，并非忙等<br>需要导入头文件<code>#import &lt;os/lock.h&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//初始化</span><br><span class="line">os_unfair_lock lock = OS_UNFAIR_LOCK_INIT;</span><br><span class="line">//加锁</span><br><span class="line">os_unfair_lock_lock(&amp;lock);</span><br><span class="line">//解锁</span><br><span class="line">os_unfair_lock_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>
<p><strong>demo</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;os_unfair_lockDemo.h&quot;</span><br><span class="line">#import &lt;os/lock.h&gt;</span><br><span class="line">@interface os_unfair_lockDemo()</span><br><span class="line">@property (assign, nonatomic) os_unfair_lock ticketLock;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation os_unfair_lockDemo</span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">self = [super init];</span><br><span class="line">if (self) &#123;</span><br><span class="line">self.ticketLock = OS_UNFAIR_LOCK_INIT;</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//卖票</span><br><span class="line">- (void)sellingTickets&#123;</span><br><span class="line">os_unfair_lock_lock(&amp;_ticketLock);</span><br><span class="line"></span><br><span class="line">[super sellingTickets];</span><br><span class="line"></span><br><span class="line">os_unfair_lock_unlock(&amp;_ticketLock);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<h4 id="3、pthread-mutex"><a href="#3、pthread-mutex" class="headerlink" title="3、pthread_mutex"></a>3、pthread_mutex</h4><p>mutex叫做”互斥锁”，等待锁的线程会处于休眠状态。需要导入头文件#import &lt;pthread.h&gt;<br>使用步骤</p>
<ul>
<li><p>1、初始化锁的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* Mutex type attributes</span><br><span class="line">*/</span><br><span class="line">#define PTHREAD_MUTEX_NORMAL        0</span><br><span class="line">#define PTHREAD_MUTEX_ERRORCHECK    1</span><br><span class="line">#define PTHREAD_MUTEX_RECURSIVE        2</span><br><span class="line">#define PTHREAD_MUTEX_DEFAULT        PTHREAD_MUTEX_NORMAL</span><br></pre></td></tr></table></figure>
</li>
<li><p>2、初始化锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 初始化锁</span><br><span class="line">pthread_mutex_init(mutex, &amp;attr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>3、初始化锁结束以后，销毁属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 销毁属性</span><br><span class="line">pthread_mutexattr_destroy(&amp;attr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>4、加锁解锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">pthread_mutex_unlock(&amp;_mutex);</span><br></pre></td></tr></table></figure>
</li>
<li><p>5、销毁锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_destroy(&amp;_mutex);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>备注：我们可以不初始化属性，在传属性的时候直接传<code>NULL</code>，表示使用默认属性<code>PTHREAD_MUTEX_NORMAL</code>。<code>pthread_mutex_init(mutex, NULL);</code></p>
<p>具体代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;pthread_mutexDemo.h&quot;</span><br><span class="line">#import &lt;pthread.h&gt;</span><br><span class="line">@interface pthread_mutexDemo()</span><br><span class="line">@property (assign, nonatomic) pthread_mutex_t ticketMutex;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation pthread_mutexDemo</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">self = [super init];</span><br><span class="line">if (self) &#123;</span><br><span class="line">// 初始化属性</span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_DEFAULT);</span><br><span class="line">// 初始化锁</span><br><span class="line">pthread_mutex_init(&amp;(_ticketMutex), &amp;attr);</span><br><span class="line">// 销毁属性</span><br><span class="line">pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//卖票</span><br><span class="line">- (void)sellingTickets&#123;</span><br><span class="line">pthread_mutex_lock(&amp;_ticketMutex);</span><br><span class="line"></span><br><span class="line">[super sellingTickets];</span><br><span class="line"></span><br><span class="line">pthread_mutex_unlock(&amp;_ticketMutex);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p><strong>死锁</strong><br>我们稍微的修改一下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//卖票</span><br><span class="line">- (void)sellingTickets&#123;</span><br><span class="line">pthread_mutex_lock(&amp;_ticketMutex);</span><br><span class="line">[super sellingTickets];</span><br><span class="line">[self sellingTickets2];</span><br><span class="line">pthread_mutex_unlock(&amp;_ticketMutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)sellingTickets2&#123;</span><br><span class="line">pthread_mutex_lock(&amp;_ticketMutex);</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">pthread_mutex_unlock(&amp;_ticketMutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<img src="/2018/12/26/9-5多线程/线程安全5.png" title="线程安全5">
<p>上面的代码就会造成<code>线程死锁</code>，因为方法<code>sellingTickets</code>的结束需要<code>sellingTickets2</code>解锁，方法<code>sellingTickets2</code>的结束需要<code>sellingTickets</code>解锁，相互引用造成死锁</p>
<p>但是<code>pthread_mutex_t</code>里面有一个属性可以解决这个问题<code>PTHREAD_MUTEX_RECURSIVE</code></p>
<p><code>PTHREAD_MUTEX_RECURSIVE</code> 递归锁：允许同一个线程对同一把锁进行重复加锁。要考重点<code>同一个线程</code>和<code>同一把锁</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">self = [super init];</span><br><span class="line">if (self) &#123;</span><br><span class="line">// 初始化属性</span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">// 初始化锁</span><br><span class="line">pthread_mutex_init(&amp;(_ticketMutex), &amp;attr);</span><br><span class="line">// 销毁属性</span><br><span class="line">pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的问题还有一个解决方案就是在方法<code>sellingTickets2</code>中重新在创建一把新的锁，两个方法的锁对象不同，就不会造成线程死锁了。</p>
<img src="/2018/12/26/9-5多线程/线程安全6.png" title="线程安全6">
<p><strong>条件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 初始化属性</span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">// 初始化锁</span><br><span class="line">pthread_mutex_init(&amp;_mutex, &amp;attr);</span><br><span class="line">// 销毁属性</span><br><span class="line">pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">// 初始化条件</span><br><span class="line">pthread_cond_t condition</span><br><span class="line">pthread_cond_init(&amp;_cond, NULL);</span><br><span class="line"></span><br><span class="line">// 等待条件</span><br><span class="line">pthread_cond_wait(&amp;_cond, &amp;_mutex);</span><br><span class="line"></span><br><span class="line">//激活一个等待该条件的线程</span><br><span class="line">pthread_cond_signal(&amp;_cond);</span><br><span class="line">//激活所有等待该条件的线程</span><br><span class="line">pthread_cond_broadcast(&amp;_cond);</span><br><span class="line"></span><br><span class="line">//销毁资源</span><br><span class="line">pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">pthread_cond_destroy(&amp;_cond);</span><br></pre></td></tr></table></figure></p>
<p>使用案例：假设我们有一个数组，里面有两个线程，一个是添加数组，一个是删除数组，我们先调用删除数组，在调用添加数组，但是在数组为空的时候不调用删除数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;pthread_mutexDemo1.h&quot;</span><br><span class="line">#import &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">@interface pthread_mutexDemo1()</span><br><span class="line">@property (assign, nonatomic) pthread_mutex_t mutex;</span><br><span class="line">@property (assign, nonatomic) pthread_cond_t cond;</span><br><span class="line">@property (strong, nonatomic) NSMutableArray *data;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation pthread_mutexDemo1</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">if (self = [super init]) &#123;</span><br><span class="line">// 初始化属性</span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">// 初始化锁</span><br><span class="line">pthread_mutex_init(&amp;_mutex, &amp;attr);</span><br><span class="line">// 销毁属性</span><br><span class="line">pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">// 初始化条件</span><br><span class="line">pthread_cond_init(&amp;_cond, NULL);</span><br><span class="line"></span><br><span class="line">self.data = [NSMutableArray array];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)otherTest</span><br><span class="line">&#123;</span><br><span class="line">[[[NSThread alloc] initWithTarget:self selector:@selector(__remove) object:nil] start];</span><br><span class="line"></span><br><span class="line">[[[NSThread alloc] initWithTarget:self selector:@selector(__add) object:nil] start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 线程1</span><br><span class="line">// 删除数组中的元素</span><br><span class="line">- (void)__remove</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">NSLog(@&quot;__remove - begin&quot;);</span><br><span class="line"></span><br><span class="line">if (self.data.count == 0) &#123;</span><br><span class="line">// 等待</span><br><span class="line">pthread_cond_wait(&amp;_cond, &amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[self.data removeLastObject];</span><br><span class="line">NSLog(@&quot;删除了元素&quot;);</span><br><span class="line"></span><br><span class="line">pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 线程2</span><br><span class="line">// 往数组中添加元素</span><br><span class="line">- (void)__add</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;_mutex);</span><br><span class="line"></span><br><span class="line">sleep(1);</span><br><span class="line"></span><br><span class="line">[self.data addObject:@&quot;Test&quot;];</span><br><span class="line">NSLog(@&quot;添加了元素&quot;);</span><br><span class="line"></span><br><span class="line">// 激活一个等待该条件的线程</span><br><span class="line">pthread_cond_signal(&amp;_cond);</span><br><span class="line"></span><br><span class="line">pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">pthread_cond_destroy(&amp;_cond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了准确测试我们可以在<code>__add</code>中<code>sleep(1)</code></p>
<img src="/2018/12/26/9-5多线程/线程安全7.png" title="线程安全7">
<h4 id="4、NSLock"><a href="#4、NSLock" class="headerlink" title="4、NSLock"></a>4、NSLock</h4><p>NSLock是对<code>mutex</code>普通锁的封装。<code>pthread_mutex_init(mutex, NULL);</code></p>
<p>NSLock 遵循 NSLocking 协议。Lock 方法是加锁，unlock 是解锁，tryLock 是尝试加锁，如果失败的话返回 NO，lockBeforeDate: 是在指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@protocol NSLocking</span><br><span class="line">- (void)lock;</span><br><span class="line">- (void)unlock;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface NSLock : NSObject &lt;NSLocking&gt; &#123;</span><br><span class="line">@private</span><br><span class="line">void *_priv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)tryLock;</span><br><span class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;</span><br><span class="line">@property (nullable, copy) NSString *name</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>使用起来也是十分的简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;LockDemo.h&quot;</span><br><span class="line">@interface LockDemo()</span><br><span class="line">@property (strong, nonatomic) NSLock *ticketLock;</span><br><span class="line">@end</span><br><span class="line">@implementation LockDemo</span><br><span class="line">//卖票</span><br><span class="line">- (void)sellingTickets&#123;</span><br><span class="line">[self.ticketLock lock];</span><br><span class="line">[super sellingTickets];</span><br><span class="line">[self.ticketLock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<h4 id="5、NSRecursiveLock"><a href="#5、NSRecursiveLock" class="headerlink" title="5、NSRecursiveLock"></a>5、NSRecursiveLock</h4><p>NSRecursiveLock是对<code>mutex</code>递归锁的封装，API跟NSLock基本一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;RecursiveLockDemo.h&quot;</span><br><span class="line">@interface RecursiveLockDemo()</span><br><span class="line">@property (nonatomic,strong) NSRecursiveLock *ticketLock;</span><br><span class="line">@end</span><br><span class="line">@implementation RecursiveLockDemo</span><br><span class="line">//卖票</span><br><span class="line">- (void)sellingTickets&#123;</span><br><span class="line">[self.ticketLock lock];</span><br><span class="line">[super sellingTickets];</span><br><span class="line">[self.ticketLock unlock];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="6、NSCondition"><a href="#6、NSCondition" class="headerlink" title="6、NSCondition"></a>6、NSCondition</h4><p>NSCondition是对<code>mutex</code>和<code>cond</code>的封装，更加面向对象，我们使用起来也更加的方便简洁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface NSCondition : NSObject &lt;NSLocking&gt; &#123;</span><br><span class="line">- (void)wait;</span><br><span class="line">- (BOOL)waitUntilDate:(NSDate *)limit;</span><br><span class="line">- (void)signal;</span><br><span class="line">- (void)broadcast;</span><br><span class="line">@property (nullable, copy) NSString *name </span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>对于上面那个数组操作的案例我们就可以变成这个样子了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 线程1</span><br><span class="line">// 删除数组中的元素</span><br><span class="line">- (void)__remove</span><br><span class="line">&#123;</span><br><span class="line">[self.condition lock];</span><br><span class="line">if (self.data.count == 0) &#123;</span><br><span class="line">// 等待</span><br><span class="line">[self.condition wait];</span><br><span class="line">&#125;</span><br><span class="line">[self.data removeLastObject];</span><br><span class="line">NSLog(@&quot;删除了元素&quot;);</span><br><span class="line">[self.condition unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 线程2</span><br><span class="line">// 往数组中添加元素</span><br><span class="line">- (void)__add</span><br><span class="line">&#123;</span><br><span class="line">[self.condition lock];</span><br><span class="line">sleep(1);</span><br><span class="line">[self.data addObject:@&quot;Test&quot;];</span><br><span class="line">NSLog(@&quot;添加了元素&quot;);</span><br><span class="line">// 信号</span><br><span class="line">[self.condition signal];</span><br><span class="line">[self.condition unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="7、NSConditionLock"><a href="#7、NSConditionLock" class="headerlink" title="7、NSConditionLock"></a>7、NSConditionLock</h4><p>NSConditionLock是对NSCondition的进一步封装，可以设置具体的条件值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface NSConditionLock : NSObject &lt;NSLocking&gt; &#123;</span><br><span class="line"> </span><br><span class="line">- (instancetype)initWithCondition:(NSInteger)condition;</span><br><span class="line"></span><br><span class="line">@property (readonly) NSInteger condition;</span><br><span class="line">- (void)lockWhenCondition:(NSInteger)condition;</span><br><span class="line">- (BOOL)tryLock;</span><br><span class="line">- (BOOL)tryLockWhenCondition:(NSInteger)condition;</span><br><span class="line">- (void)unlockWithCondition:(NSInteger)condition;</span><br><span class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;</span><br><span class="line">- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;</span><br><span class="line">@property (nullable, copy) NSString *name;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>里面有三个常用的方法</p>
<ul>
<li>1、<code>initWithCondition：</code>初始化<code>Condition</code>，并且设置状态值</li>
<li>2、<code>lockWhenCondition:(NSInteger)condition:</code>当状态值为condition的时候加锁</li>
<li>3、<code>unlockWithCondition:(NSInteger)condition</code>当状态值为condition的时候解锁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@interface NSConditionLockDemo()</span><br><span class="line">@property (strong, nonatomic) NSConditionLock *conditionLock;</span><br><span class="line">@end</span><br><span class="line">@implementation NSConditionLockDemo</span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">if (self = [super init]) &#123;</span><br><span class="line">self.conditionLock = [[NSConditionLock alloc] initWithCondition:1];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)otherTest</span><br><span class="line">&#123;</span><br><span class="line">[[[NSThread alloc] initWithTarget:self selector:@selector(__one) object:nil] start];</span><br><span class="line">[[[NSThread alloc] initWithTarget:self selector:@selector(__two) object:nil] start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__one</span><br><span class="line">&#123;</span><br><span class="line">[self.conditionLock lock];</span><br><span class="line">NSLog(@&quot;__one&quot;);</span><br><span class="line">sleep(1);</span><br><span class="line">[self.conditionLock unlockWithCondition:2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__two</span><br><span class="line">&#123;</span><br><span class="line">[self.conditionLock lockWhenCondition:2];</span><br><span class="line">NSLog(@&quot;__two&quot;);</span><br><span class="line">[self.conditionLock unlockWithCondition:3];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<img src="/2018/12/26/9-5多线程/线程安全8.png" title="线程安全8">
<h4 id="8、dispatch-semaphore"><a href="#8、dispatch-semaphore" class="headerlink" title="8、dispatch_semaphore"></a>8、dispatch_semaphore</h4><ul>
<li>semaphore叫做”信号量”</li>
<li>信号量的初始值，可以用来控制线程并发访问的最大数量</li>
<li>信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//表示最多开启5个线程</span><br><span class="line">dispatch_semaphore_create(5);</span><br><span class="line">// 如果信号量的值 &gt; 0，就让信号量的值减1，然后继续往下执行代码</span><br><span class="line">// 如果信号量的值 &lt;= 0，就会休眠等待，直到信号量的值变成&gt;0，就让信号量的值减1，然后继续往下执行代码</span><br><span class="line">dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">// 让信号量的值+1</span><br><span class="line">dispatch_semaphore_signal(self.semaphore);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@interface dispatch_semaphoreDemo()</span><br><span class="line">@property (strong, nonatomic) dispatch_semaphore_t semaphore;</span><br><span class="line">@end</span><br><span class="line">@implementation dispatch_semaphoreDemo</span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">if (self = [super init]) &#123;</span><br><span class="line">self.semaphore = dispatch_semaphore_create(1);</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)otherTest</span><br><span class="line">&#123;</span><br><span class="line">for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">[[[NSThread alloc] initWithTarget:self selector:@selector(test) object:nil] start];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">// 如果信号量的值 &gt; 0，就让信号量的值减1，然后继续往下执行代码</span><br><span class="line">// 如果信号量的值 &lt;= 0，就会休眠等待，直到信号量的值变成&gt;0，就让信号量的值减1，然后继续往下执行代码</span><br><span class="line">dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">sleep(2);</span><br><span class="line">NSLog(@&quot;test - %@&quot;, [NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">// 让信号量的值+1</span><br><span class="line">dispatch_semaphore_signal(self.semaphore);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>我们在运行代码打印的时候发现，每隔一秒出现一次打印。虽然我们同时开启20个线程，但是一次只能访问一条线程的资源</p>
<h4 id="9、dispatch-queue"><a href="#9、dispatch-queue" class="headerlink" title="9、dispatch_queue"></a>9、dispatch_queue</h4><p>使用GCD的串行队列也可以实现线程同步的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">// 追加任务1</span><br><span class="line">for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">// 追加任务2</span><br><span class="line">for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="10、-synchronized"><a href="#10、-synchronized" class="headerlink" title="10、@synchronized"></a>10、@synchronized</h4><p><code>@synchronized</code>是对<code>mutex</code>递归锁的封装，<br><code>@synchronized(obj)</code>内部会生成obj对应的递归锁，然后进行加锁、解锁操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//卖票</span><br><span class="line">- (void)sellingTickets&#123;</span><br><span class="line">@synchronized ([self class]) &#123;</span><br><span class="line">[super sellingTickets];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对是实现底层我们可以在<code>objc4的objc-sync.mm文件中找到</code><br><code>synchronized</code>就是在开始和结束的时候调用了<code>objc_sync_enter</code>&amp;<code>objc_sync_exit</code>方法。</p>
<p><code>objc_sync_enter</code>实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int objc_sync_enter(id obj)</span><br><span class="line">&#123;</span><br><span class="line">int result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">if (obj) &#123;</span><br><span class="line">SyncData* data = id2data(obj, ACQUIRE);</span><br><span class="line">assert(data);</span><br><span class="line">data-&gt;mutex.lock();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// @synchronized(nil) does nothing</span><br><span class="line">if (DebugNilSync) &#123;</span><br><span class="line">_objc_inform(&quot;NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug&quot;);</span><br><span class="line">&#125;</span><br><span class="line">objc_sync_nil();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就是根据<code>id2data</code>方法找到一个<code>data</code>对象，然后在对<code>data</code>对象进行<code>mutex.lock()</code>加锁操作。我们点击进入<code>id2data</code>方法继续查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define LIST_FOR_OBJ(obj) sDataLists[obj].data</span><br><span class="line">static StripedMap&lt;SyncList&gt; sDataLists;</span><br></pre></td></tr></table></figure></p>
<p>发现获取<code>data</code>对象的方法其实就是根据<code>sDataLists[obj].data</code>这个方法来实现的，也就是一个哈希表。</p>
<p><a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="noopener">关于 @synchronized，这儿比你想知道的还要多</a></p>
<h4 id="11、atomic"><a href="#11、atomic" class="headerlink" title="11、atomic"></a>11、atomic</h4><ul>
<li>atomic用于保证属性setter、getter的原子性操作，相当于在getter和setter内部加了线程同步的锁</li>
<li>可以参考源码objc4的objc-accessors.mm</li>
<li>它并不能保证使用属性的过程是线程安全的</li>
</ul>
<h4 id="12、pthread-rwlock：读写锁"><a href="#12、pthread-rwlock：读写锁" class="headerlink" title="12、pthread_rwlock：读写锁"></a>12、pthread_rwlock：读写锁</h4><p>pthread_rwlock经常用于文件等数据的读写操作，需要导入头文件<code>#import &lt;pthread.h&gt;</code></p>
<p>iOS中的读写安全方案需要注意一下场景</p>
<ul>
<li>1、同一时间，只能有1个线程进行写的操作</li>
<li>2、同一时间，允许有多个线程进行读的操作</li>
<li>3、同一时间，不允许既有写的操作，又有读的操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//初始化锁</span><br><span class="line">pthread_rwlock_t lock;</span><br><span class="line">pthread_rwlock_init(&amp;_lock, NULL);</span><br><span class="line"></span><br><span class="line">//读加锁</span><br><span class="line">pthread_rwlock_rdlock(&amp;_lock);</span><br><span class="line">//读尝试加锁</span><br><span class="line">pthread_rwlock_trywrlock(&amp;_lock)</span><br><span class="line"></span><br><span class="line">//写加锁</span><br><span class="line">pthread_rwlock_wrlock(&amp;_lock);</span><br><span class="line">//写尝试加锁</span><br><span class="line">pthread_rwlock_trywrlock(&amp;_lock)</span><br><span class="line"></span><br><span class="line">//解锁</span><br><span class="line">pthread_rwlock_unlock(&amp;_lock);</span><br><span class="line">//销毁</span><br><span class="line">pthread_rwlock_destroy(&amp;_lock);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;pthread.h&gt;</span><br><span class="line">@interface pthread_rwlockDemo ()</span><br><span class="line">@property (assign, nonatomic) pthread_rwlock_t lock;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation pthread_rwlockDemo</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">self = [super init];</span><br><span class="line">if (self) &#123;</span><br><span class="line">// 初始化锁</span><br><span class="line">pthread_rwlock_init(&amp;_lock, NULL);</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)otherTest&#123;</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">[self read];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">[self write];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)read &#123;</span><br><span class="line">pthread_rwlock_rdlock(&amp;_lock);</span><br><span class="line">sleep(1);</span><br><span class="line">NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">pthread_rwlock_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)write</span><br><span class="line">&#123;</span><br><span class="line">pthread_rwlock_wrlock(&amp;_lock);</span><br><span class="line">sleep(1);</span><br><span class="line">NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">pthread_rwlock_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">pthread_rwlock_destroy(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<img src="/2018/12/26/9-5多线程/线程安全9.png" title="线程安全9">
<p>我们可以发现读操作1s有可能出现多次，但是写操作不会</p>
<h4 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h4><p>这个函数传入的并发队列必须是自己通过dispatch_queue_cretate创建的<br>如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//初始化</span><br><span class="line">self.queue = dispatch_queue_create(&quot;rw_queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">//读操作</span><br><span class="line">dispatch_async(self.queue, ^&#123;</span><br><span class="line">&#125;);</span><br><span class="line">//写操作</span><br><span class="line">dispatch_barrier_async(self.queue, ^&#123;</span><br><span class="line"> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="锁的性能比较"><a href="#锁的性能比较" class="headerlink" title="锁的性能比较"></a>锁的性能比较</h3><p>性能从高到低排序</p>
<ul>
<li>1、os_unfair_lock</li>
<li>2、OSSpinLock</li>
<li>3、dispatch_semaphore</li>
<li>4、pthread_mutex</li>
<li>5、dispatch_queue(DISPATCH_QUEUE_SERIAL)</li>
<li>6、NSLock</li>
<li>7、NSCondition</li>
<li>8、pthread_mutex(recursive)</li>
<li>9、NSRecursiveLock</li>
<li>10、NSConditionLock</li>
<li>11、@synchronized</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/26/9-4多线程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NSLegend">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/26/9-4多线程/" itemprop="url">9.4多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-26T10:35:58+08:00">
                2018-12-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS底层/" itemprop="url" rel="index">
                    <span itemprop="name">iOS底层</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">## NSOperation介绍 </span><br><span class="line"></span><br><span class="line">NSOperation、NSOperationQueue 是苹果提供给我们的一套多线程解决方案。实际上 NSOperation、NSOperationQueue 是基于 GCD 更高一层的封装，完全面向对象</span><br><span class="line"></span><br><span class="line">好处</span><br><span class="line">- 1、可添加完成的代码块，在操作完成后执行</span><br><span class="line">- 2、添加操作之间的依赖关系，方便的控制执行顺序</span><br><span class="line">- 3、设定操作执行的优先级</span><br><span class="line">- 4、可以很方便的取消一个操作的执行</span><br><span class="line">- 5、使用 KVO 观察对操作执行状态的更改：isExecuteing、isFinished、isCancelled</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">既然是基于 GCD 的更高一层的封装。那么，GCD 中的一些概念同样适用于 NSOperation、NSOperationQueue。在 NSOperation、NSOperationQueue 中也有类似的任务（操作）和队列（操作队列）的概念</span><br><span class="line"></span><br><span class="line">**操作（Operation）**</span><br><span class="line">- 1、执行操作的意思，换句话说就是你在线程中执行的那段代码</span><br><span class="line">- 2、在 `GCD `中是放在 `block` 中的。在 `NSOperation` 中，我们使用 NSOperation 子类 `NSInvocationOperation`、`NSBlockOperation`，或者自定义子类来封装操作</span><br><span class="line"></span><br><span class="line">**操作队列（Operation Queues）**</span><br><span class="line">- 1、这里的队列指操作队列，即用来存放操作的队列。不同于 GCD 中的调度队列 FIFO（先进先出）的原则。NSOperationQueue 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。</span><br><span class="line">- 2、操作队列通过设置最大并发操作数（maxConcurrentOperationCount）来控制并发、串行</span><br><span class="line">- 3、NSOperationQueue 为我们提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 常用API</span><br><span class="line"></span><br><span class="line">**NSOperation常用属性和方法**</span><br><span class="line">- 1、开始取消操作</span><br><span class="line">    - `- (void)start`：对于并发Operation需要重写该方法，也可以不把operation加入到队列中，手动触发执行，与调用普通方法一样</span><br><span class="line">    - `- (void)main`：非并发Operation需要重写该方法</span><br><span class="line">    - `- (void)cancel`：可取消操作，实质是标记 isCancelled 状态</span><br><span class="line">- 2、判断操作状态方法</span><br><span class="line">    - `- (BOOL)isFinished;` 判断操作是否已经结束</span><br><span class="line">    - `- (BOOL)isCancelled` 判断操作是否已经标记为取消</span><br><span class="line">    - `- (BOOL)isExecuting;`判断操作是否正在在运行</span><br><span class="line">    - `- (BOOL)isReady;`判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关。</span><br><span class="line"></span><br><span class="line">- 3、操作同步</span><br><span class="line">    - `- (void)waitUntilFinished;`阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步</span><br><span class="line">    - `- (void)setCompletionBlock:(void (^)(void))block;`  会在当前操作执行完毕时执行 completionBlock </span><br><span class="line">    - `- (void)addDependency:(NSOperation *)op;` 添加依赖，使当前操作依赖于操作 op 的完成</span><br><span class="line">    - `- (void)removeDependency:(NSOperation *)op;` 移除依赖，取消当前操作对操作 op 的依赖。</span><br><span class="line">    - `@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies;` 在当前操作开始执行之前完成执行的所有操作对象数组。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**NSOperationQueue 常用属性和方法**</span><br><span class="line"></span><br><span class="line">- 1、取消/暂停/恢复操作</span><br><span class="line">    - `- (void)cancelAllOperations;` 可以取消队列的所有操作</span><br><span class="line">    - `- (BOOL)isSuspended;` 判断队列是否处于暂停状态。 YES 为暂停状态，NO 为恢复状态</span><br><span class="line">    - `- (void)setSuspended:(BOOL)b;` 可设置操作的暂停和恢复，YES 代表暂停队列，NO 代表恢复队列</span><br><span class="line"></span><br><span class="line">- 2、操作同步</span><br><span class="line">    - `- (void)waitUntilAllOperationsAreFinished;` 阻塞当前线程，直到队列中的操作全部执行完毕。</span><br><span class="line">- 3、添加/获取操作</span><br><span class="line">    - `- (void)addOperationWithBlock:(void (^)(void))block;` 向队列中添加一个 NSBlockOperation 类型操作对象</span><br><span class="line">    - `- (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait;`向队列中添加操作数组，wait 标志是否阻塞当前线程直到所有操作结束</span><br><span class="line">    - `- (NSArray *)operations;` 当前在队列中的操作数组（某个操作执行结束后会自动从这个数组清除）</span><br><span class="line">    - `- (NSUInteger)operationCount;` 当前队列中的操作数</span><br><span class="line">- 4、获取队列</span><br><span class="line">    -   `+ (id)currentQueue;` 获取当前队列，如果当前线程不是在 NSOperationQueue 上运行则返回 nil。</span><br><span class="line">    - `+ (id)mainQueue;`  获取主队列。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 简单使用</span><br><span class="line"></span><br><span class="line">NSOperation 需要配合 NSOperationQueue 来实现多线程。因为默认情况下，NSOperation 单独使用时系统同步执行操作，配合 NSOperationQueue 我们能更好的实现异步执行</span><br><span class="line"></span><br><span class="line">实现步骤</span><br><span class="line">- 1、创建操作：先将需要执行的操作封装到一个 NSOperation 对象中</span><br><span class="line">- 2、创建队列：创建 NSOperationQueue 对象</span><br><span class="line">- 3、将操作加入到队列中：将 NSOperation 对象添加到 NSOperationQueue 对象中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSOperation 是个抽象类，不能用来封装操作。我们只有使用它的子类来封装操作</span><br><span class="line">- 1、使用子类 NSInvocationOperation</span><br><span class="line">- 2、使用子类 NSBlockOperation</span><br><span class="line">- 3、自定义继承自 NSOperation 的子类，通过实现内部相应的方法来封装操作。</span><br><span class="line"></span><br><span class="line">#### 使用子类 `NSInvocationOperation`</span><br><span class="line"></span><br><span class="line">在主线程中操作</span><br></pre></td></tr></table></figure>
<ul>
<li>(void)Operation1{<br>//1、创建NSInvocationOperation对象<br>NSInvocationOperation *op = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(test) object:nil];<br>//2、开始调用<br>[op start];<br>}</li>
</ul>
<ul>
<li>(void)test{<br>for (NSInteger i = 0; i &lt; 2; i++) {<br>NSLog(@”当前线程:%@”,[NSThread currentThread]);<br>}<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% asset_img NSOperation1.png  NSOperation1 %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果在其他线程中操作</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(Operation1) object:@”Hello, World”];<br>//设置线程的名字，方便查看<br>[thread setName:@”firstThread”];<br>//启动线程<br>[thread start];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img NSOperation2.png  NSOperation2 %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**总结**：在没有使用 `NSOperationQueue`、在主线程中单独使用使用子类 `NSInvocationOperation` 执行一个操作的情况下，操作是在当前线程执行的，并`没有开启新线程`。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 使用子类 `NSBlockOperation`</span><br><span class="line"></span><br><span class="line">在主线程中</span><br></pre></td></tr></table></figure></p>
<ul>
<li>(void)Operation2{<br>//1、使用NSBlockOperation<br>NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{<br>NSLog(@”当前线程:%@”,[NSThread currentThread]);<br>}];<br>//2、开始调用<br>[op start];<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img NSOperation3.png  NSOperation3 %&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(Operation2) object:@”Hello, World”];<br>//设置线程的名字，方便查看<br>[thread setName:@”firstThread”];<br>//启动线程<br>[thread start];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img NSOperation4.png  NSOperation4 %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**总结**：在没有使用 `NSOperationQueue`、在主线程中单独使用使用子类 `NSBlockOperation` 执行一个操作的情况下，操作是在当前线程执行的，并`没有开启新线程`。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**addExecutionBlock**</span><br><span class="line"></span><br><span class="line">`NSBlockOperation` 还提供了一个方法 `addExecutionBlock:`，通过 `addExecutionBlock:` 就可以为 `NSBlockOperation` 添加额外的操作。这些操作（包括 blockOperationWithBlock 中的操作）可以在不同的线程中同时`（并发）`执行。只有当所有相关的操作已经完成执行时，才视为完成。每添加一个`addExecutionBlock:`就是开启一个异步并发执行事件</span><br></pre></td></tr></table></figure></p>
<p>//1、使用NSBlockOperation<br>NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{<br>NSLog(@”当前线程:%@”,[NSThread currentThread]);<br>}];<br>[op addExecutionBlock:^{<br>for (int i = 0; i &lt; 2; i++) {<br>NSLog(@”当前线程2：%@”, [NSThread currentThread]); // 打印当前线程<br>}<br>}];<br>[op addExecutionBlock:^{<br>for (int i = 0; i &lt; 2; i++) {<br>NSLog(@”当前线程3：%@”, [NSThread currentThread]); // 打印当前线程<br>}<br>}];<br>[op addExecutionBlock:^{<br>for (int i = 0; i &lt; 2; i++) {<br>NSLog(@”当前线程4：%@”, [NSThread currentThread]); // 打印当前线程<br>}<br>}];</p>
<p>//2、开始调用<br>[op start];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% asset_img NSOperation5.png  NSOperation5 %&#125;</span><br><span class="line"></span><br><span class="line">#### 自定义继承自 NSOperation 的子类</span><br><span class="line"></span><br><span class="line">如果使用子类` NSInvocationOperation`、`NSBlockOperation `不能满足日常需求，我们可以使用自定义继承自 NSOperation 的子类。可以通过重写 `main `或者 `start `方法 来定义自己的 `NSOperation 对象`。重写`main`方法比较简单，我们不需要管理操作的状态属性` isExecuting` 和 `isFinished`。当 main 执行完返回的时候，这个操作就结束了</span><br></pre></td></tr></table></figure></p>
<p>@interface JHOperation : NSOperation</p>
<p>@end</p>
<p>#import “JHOperation.h”</p>
<p>@implementation JHOperation</p>
<ul>
<li>(void)main {<br>if (!self.isCancelled) {<br>for (int i = 0; i &lt; 2; i++) {</li>
</ul>
<p>NSLog(@”当前线程：%@”, [NSThread currentThread]);<br>}<br>}<br>}</p>
<p>@end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用</span><br></pre></td></tr></table></figure></p>
<ul>
<li>(void)Operation3{<br>// 1.创建 JHOperation 对象<br>JHOperation *op = [[JHOperation alloc] init];<br>// 2.调用 start 方法开始执行操作<br>[op start];<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### `NSOperationQueue` 创建队列</span><br><span class="line"></span><br><span class="line"> NSOperationQueue 一共有两种队列：主队列、自定义队列。其中自定义队列同时包含了串行、并发功能</span><br><span class="line"></span><br><span class="line">**主队列**</span><br><span class="line">凡是添加到主队列中的操作，都会放到主线程中执行（注：不包括操作使用addExecutionBlock:添加的额外操作)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>// 主队列获取方法<br>NSOperationQueue *queue = [NSOperationQueue mainQueue];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**自定义队列**</span><br><span class="line">添加到这种队列中的操作，就会自动放到子线程中执行。同时包含了：串行、并发功能。</span><br></pre></td></tr></table></figure></p>
<p>// 自定义队列创建方法<br>NSOperationQueue *queue = [[NSOperationQueue alloc] init];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 将操作加入到队列中</span><br><span class="line"></span><br><span class="line">NSOperation 需要配合 NSOperationQueue 来实现多线程，总共有两种方法：</span><br><span class="line">- 1、`- (void)addOperation:(NSOperation *)op;` 需要先创建操作，再将创建好的操作加入到创建好的队列中去</span><br><span class="line">- 2、`- (void)addOperationWithBlock:(void (^)(void))block;` 无需先创建操作，在 block 中添加操作，直接将包含操作的 block 加入到队列中。</span><br><span class="line"></span><br><span class="line">**addOperation**</span><br></pre></td></tr></table></figure></p>
<ul>
<li>(void)Operation4{<br>//1、创建队列<br>NSOperationQueue *queue = [[NSOperationQueue alloc]init];</li>
</ul>
<p>//2、创建操作<br>NSBlockOperation <em>op1 = [NSBlockOperation blockOperationWithBlock:^{<br>NSLog(@”当前线程1:%@”,[NSThread currentThread]);<br>}];<br>NSBlockOperation </em>op2 = [NSBlockOperation blockOperationWithBlock:^{<br>NSLog(@”当前线程2:%@”,[NSThread currentThread]);<br>}];<br>NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^{<br>NSLog(@”当前线程3:%@”,[NSThread currentThread]);<br>}];</p>
<p>//3、添加操作<br>[queue addOperation:op1];<br>[queue addOperation:op2];<br>[queue addOperation:op3];<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% asset_img NSOperation6.png  NSOperation6 %&#125;</span><br><span class="line"></span><br><span class="line">**addOperationWithBlock**</span><br><span class="line"></span><br><span class="line">无需先创建操作，在 block 中添加操作，直接将包含操作的 block 加入到队列中。</span><br></pre></td></tr></table></figure></p>
<ul>
<li>(void)Operation5{<br>NSOperationQueue *queue = [[NSOperationQueue alloc]init];<br>[queue addOperationWithBlock:^{<br>NSLog(@”当前线程1:%@”,[NSThread currentThread]);<br>}];<br>[queue addOperationWithBlock:^{<br>NSLog(@”当前线程2:%@”,[NSThread currentThread]);<br>}];<br>[queue addOperationWithBlock:^{<br>NSLog(@”当前线程3:%@”,[NSThread currentThread]);<br>}];<br>}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#### 最大并发操作数量 `maxConcurrentOperationCount`</span><br><span class="line"></span><br><span class="line">`maxConcurrentOperationCount`最大并发操作数量</span><br><span class="line">- maxConcurrentOperationCount 默认情况下为-1，表示不进行限制，可进行并发执行。</span><br><span class="line">- maxConcurrentOperationCount 为1时，队列为串行队列。只能串行执行。</span><br><span class="line">- maxConcurrentOperationCount 大于1时，队列为并发队列。操作并发执行，当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整为 min&#123;自己设定的值，系统设定的默认最大值&#125;</span><br></pre></td></tr></table></figure>
<p> NSOperationQueue *queue = [[NSOperationQueue alloc]init];<br> queue.maxConcurrentOperationCount = 1; // 串行队列<br> queue.maxConcurrentOperationCount = 2; // 并发队列，一次只能执行两个并发队列<br> [queue addOperationWithBlock:^{<br> NSLog(@”当前线程1:%@”,[NSThread currentThread]);<br> }];<br> [queue addOperationWithBlock:^{<br> NSLog(@”当前线程2:%@”,[NSThread currentThread]);<br> }];<br> [queue addOperationWithBlock:^{<br> NSLog(@”当前线程3:%@”,[NSThread currentThread]);<br> }];<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> ####  NSOperation 操作依赖</span><br><span class="line"> </span><br><span class="line">NSOperation、NSOperationQueue 最吸引人的地方是它能添加操作之间的依赖关系。通过操作依赖，我们可以很方便的控制操作之间的执行先后顺序</span><br><span class="line"></span><br><span class="line">- `- (void)addDependency:(NSOperation *)op; `添加依赖，使当前操作依赖于操作 op 的完成。</span><br><span class="line">- `- (void)removeDependency:(NSOperation *)op; `移除依赖，取消当前操作对操作 op 的依赖。</span><br><span class="line">- `@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies;` 在当前操作开始执行之前完成执行的所有操作对象数组</span><br></pre></td></tr></table></figure></p>
<ul>
<li>(void)Operation6{<br>NSOperationQueue <em>queue = [[NSOperationQueue alloc]init];<br>//2、创建操作<br>NSBlockOperation </em>op1 = [NSBlockOperation blockOperationWithBlock:^{<br>[NSThread sleepForTimeInterval:1];<br>NSLog(@”当前线程1:%@”,[NSThread currentThread]);<br>}];<br>NSBlockOperation <em>op2 = [NSBlockOperation blockOperationWithBlock:^{<br>[NSThread sleepForTimeInterval:2];<br>NSLog(@”当前线程2:%@”,[NSThread currentThread]);<br>}];<br>NSBlockOperation </em>op3 = [NSBlockOperation blockOperationWithBlock:^{<br>NSLog(@”当前线程3:%@”,[NSThread currentThread]);<br>}];</li>
</ul>
<p>//3、添加依赖<br>[op3 addDependency:op1];<br>[op3 addDependency:op2];<br>//4、添加操作<br>[queue addOperation:op1];<br>[queue addOperation:op2];<br>[queue addOperation:op3];</p>
<p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">上面`op3`依赖`op1&amp;op2`执行完成才能执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% asset_img NSOperation7.png  NSOperation7 %&#125;</span><br><span class="line"></span><br><span class="line">#### NSOperation 优先级</span><br><span class="line"></span><br><span class="line">NSOperation 提供了`queuePriority（优先级）`属性，`queuePriority`属性适用于同一操作队列中的操作，不适用于不同操作队列中的操作。默认情况下，所有新创建的操作对象优先级都是`NSOperationQueuePriorityNormal`。但是我们可以通过`setQueuePriority:`方法来改变当前操作在同一队列中的执行优先级</span><br></pre></td></tr></table></figure></p>
<p>// 优先级的取值<br>typedef NS_ENUM(NSInteger, NSOperationQueuePriority) {<br>NSOperationQueuePriorityVeryLow = -8L,<br>NSOperationQueuePriorityLow = -4L,<br>NSOperationQueuePriorityNormal = 0,<br>NSOperationQueuePriorityHigh = 4,<br>NSOperationQueuePriorityVeryHigh = 8<br>};</p>
<p><code>`</code></p>
<p>对于添加到队列中的操作，首先进入准备就绪的状态（<code>就绪状态取决于操作之间的依赖关系</code>），然后进入就绪状态的操作的开始执行顺序由操作之间相对的优先级决定（优先级是操作对象自身的属性）</p>
<p>说明：优先级高的任务，调用的几率会更大。</p>
<p><a href="https://www.jianshu.com/p/4b1d77054b35" target="_blank" rel="noopener">参考：iOS 多线程：『NSOperation、NSOperationQueue』详尽总结</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/26/9-3多线程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NSLegend">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/26/9-3多线程/" itemprop="url">9.3多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-26T10:35:53+08:00">
                2018-12-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS底层/" itemprop="url" rel="index">
                    <span itemprop="name">iOS底层</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="GCD介绍"><a href="#GCD介绍" class="headerlink" title="GCD介绍"></a>GCD介绍</h2><ul>
<li>1、GCD简介</li>
<li>2、GCD任务和队列</li>
<li>3、GCD的基本使用</li>
<li>4、线程间的通信</li>
<li>5、GCD的其他方法（栅栏方法：dispatch_barrier_async、延时执行方法：dispatch_after、一次性代码（只执行一次):dispatch_once、快速迭代方法：dispatch_apply、队列组：dispatch_group、信号量：dispatch_semaphore）<blockquote>
<p>对于GCD的基本介绍，<a href="https://www.jianshu.com/p/2d57c72016c6" target="_blank" rel="noopener">这篇文章</a>讲的已经十分详细了。</p>
</blockquote>
</li>
</ul>
<h3 id="1、GCD简介"><a href="#1、GCD简介" class="headerlink" title="1、GCD简介"></a>1、GCD简介</h3><blockquote>
<p>Grand Central Dispatch(GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序已支持多核处理器以及其他对称多处理系统。它是一个在线程模式的基础上执行的并发任务。在 Mac OS X 10.6 雪豹中首次推出，也可在 iOS 4 及以上版本使用。</p>
</blockquote>
<p>GCD的好处具体如下：</p>
<ul>
<li>GCD可用于多核的并行运算</li>
<li>GCD会自动利用更多的CPU内核（比如双核、四核）</li>
<li>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li>
<li>程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码</li>
</ul>
<h3 id="2、GCD任务和队列"><a href="#2、GCD任务和队列" class="headerlink" title="2、GCD任务和队列"></a>2、GCD任务和队列</h3><p>GCD中两个核心概念：任务和队列</p>
<h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p><strong>任务</strong>：就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在GCD中是放在block中的</p>
<ul>
<li><p><strong>同步执行（sync）</strong></p>
<ul>
<li>同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。</li>
<li>只能在当前线程中执行任务，<code>不具备</code>开启新线程的能力</li>
</ul>
</li>
<li><p><strong>异步执行（async）</strong></p>
<ul>
<li>异步添加任务到指定的队列中，它不会做任务等待，可以继续执行任务。</li>
<li>可以在新的线程中执行任务，<code>具备</code>开启新线程的能力。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 同步执行任务创建方法</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">// 这里放同步执行任务代码</span><br><span class="line">&#125;);</span><br><span class="line">// 异步执行任务创建方法</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">// 这里放异步执行任务代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p><strong>队列（Dispatch Queue）</strong>：这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。</p>
<ul>
<li><p><strong>串行队列（Serial Dispatch Queue）</strong></p>
<ul>
<li>每次只有一个任务被执行。让任务一个接着一个的执行。（只开启一个线程，一个任务执行完毕后，再执行下一个任务）</li>
</ul>
</li>
<li><p><strong>并发队列（Concurrent Dispatch Queue）</strong></p>
<ul>
<li>可以让多个任务并发（同时）执行。（可以开启多个线程，并且同时执行任务）</li>
</ul>
</li>
</ul>
<p><code>并发队列的并发功能只有在异步（dispatch_async）函数下才有效</code></p>
<p><strong>队列的创建方法/获取方法</strong></p>
<p>可以使用<code>dispatch_queue_create</code>来创建队列，需要传入两个参数，第一个参数表示队列的唯一标志符，用于DEBUG,可为空，Dispatch Queue的名称推荐使用应用程序ID这种逆序全程域名；第二个参数用来识别是串行队列还是并发队列。<code>DISPATCH_QUEUE_SERIAL</code>表示串行队列，<code>DISPATCH_QUEUE_CONCURRENT</code>表示并发队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//串行队列的创建方法</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;net.it.testQueue&quot;,DISPATCH_QUEUE_SERIAL);</span><br><span class="line">//并发队列的创建方法</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;net.it.testQueue&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
<p><strong>对于串行队列，GCD提供了的一种特殊的串行队列：主队列（Main Dispatch Queue）</strong></p>
<ul>
<li>所有放在主队列中的任务，都会放到主线程中执行</li>
<li>可用dispatch_get_main_queue()获得主队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//主队列的获取方法</span><br><span class="line">dispatch_queue()_t queue =  dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>
<p><strong>对于并发队列，GCD默认提供了全局并发队列（Global Dispatch Queue）</strong><br>可以使用<code>dispatch_get_global_queue()</code>来获取。需要传入两个参数。第一个参数表示队列优先级，一般用DISPATCH_QUEUE_PRIORITY_DEFAULT。第二个参数暂时没用，用0即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//全局并发队列的获取方法</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);</span><br></pre></td></tr></table></figure>
<img src="/2018/12/26/9-3多线程/GCD.png" title="GCD">
<p><code>使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）</code><br><code>并发功能只有在异步函数才会生效</code></p>
<h3 id="3、GCD的基本使用"><a href="#3、GCD的基本使用" class="headerlink" title="3、GCD的基本使用"></a>3、GCD的基本使用</h3><p><strong>同步串行队列</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">// 追加任务1</span><br><span class="line">for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">// 追加任务2</span><br><span class="line">for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<img src="/2018/12/26/9-3多线程/GCD1.png" title="GCD1">
<p>根据打印结果可知，<code>同步串行队列即没有开启新的线程，也没有异步执行</code></p>
<p><strong>同步并发队列</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">// 追加任务1</span><br><span class="line">for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">// 追加任务2</span><br><span class="line">for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<img src="/2018/12/26/9-3多线程/GCD1.png" title="GCD1">
<p><strong>异步串行队列</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;主线程：%@&quot;,[NSThread currentThread]);</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">NSLog(@&quot;1====%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">NSLog(@&quot;2====%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<img src="/2018/12/26/9-3多线程/GCD2.png" title="GCD2">
<p>结果：<code>有开启新的线程，串行执行任务</code></p>
<p><strong>异步并行队列</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;主线程：%@&quot;,[NSThread currentThread]);</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2];</span><br><span class="line">NSLog(@&quot;1====%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2];</span><br><span class="line">NSLog(@&quot;2====%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<img src="/2018/12/26/9-3多线程/GCD3.png" title="GCD3">
<p>结果：<code>有开启新的线程，并发执行任务</code>。想要出现明显的并发执行效果，可以<code>sleep</code>一下</p>
<p><strong>sync函数造成的线程死锁</strong></p>
<p>首先你要了解同步和异步执行的概念，同步和异步不是为了是否创建一个新的线程，同步会阻塞当前函数的返回，异步函数会立即返回执行下面的代码；队列是一种数据结构，队列是一种FIFO,LIFO等控制任务的执行顺序，至于是否会开辟一个新的线程，因为同步函数会等待函数的返回，所以在当前线程执行就行了，没必要浪费资源再开辟新的线程。如果是异步函数，当前线程需要立即函数返回，然后往下执行，所以函数里面的人物必须要开辟一个新的线程去执行这个任务。</p>
<p><code>队列上是放任务的，而线程是去执行队列上的任务的</code></p>
<p>【问题1】：以下代码是在主线程执行的，会不会产生死锁？会！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;执行任务1&quot;);</span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">NSLog(@&quot;执行任务2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;执行任务3&quot;);</span><br></pre></td></tr></table></figure></p>
<img src="/2018/12/26/9-3多线程/GCD4.png" title="GCD4">
<p><code>dispatch_sync立马在当前线程同步执行任务</code></p>
<p>分析：</p>
<ul>
<li>1、主线程中任务执行：<code>任务1</code>、<code>sync</code>、<code>任务3</code></li>
<li>2、主队列：<code>viewDidLoad</code>、<code>任务2</code></li>
</ul>
<p>其中在主队列<code>viewDidLoad</code>里面的<code>任务3</code>执行结束才会执行<code>任务2</code>；而主线程中执行完<code>sync</code>才会执行<code>任务3</code>。也就是<code>任务2</code>等待<code>任务3</code>执行，<code>任务3</code>也在等待<code>任务2</code>执行，造成死锁。</p>
<img src="/2018/12/26/9-3多线程/GCD5.png" title="GCD5">
<p>【问题2】：以下代码是在主线程执行的，会不会产生死锁？不会！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)interview02</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">NSLog(@&quot;执行任务1&quot;);</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">NSLog(@&quot;执行任务2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;执行任务3&quot;);</span><br><span class="line"></span><br><span class="line">// dispatch_async不要求立马在当前线程同步执行任务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为<code>dispatch_async</code>不要求立马在当前线程同步执行任务，不会造成线程死锁</p>
<p>【问题3】：以下代码是在主线程执行的，会不会产生死锁？会！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;执行任务1&quot;);</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;myqueu&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_async(queue, ^&#123; // 0</span><br><span class="line">NSLog(@&quot;执行任务2&quot;);</span><br><span class="line"></span><br><span class="line">dispatch_sync(queue, ^&#123; // 1</span><br><span class="line">NSLog(@&quot;执行任务3&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;执行任务4&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;执行任务5&quot;);</span><br></pre></td></tr></table></figure>
<img src="/2018/12/26/9-3多线程/GCD6.png" title="GCD6">
<p>其中<code>执行任务3</code>和<code>执行任务4</code>之间造成死锁</p>
<p>【问题4】：以下代码是在主线程执行的，会不会产生死锁？不会！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)interview04</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">NSLog(@&quot;执行任务1&quot;);</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;myqueu&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123; // 0</span><br><span class="line">NSLog(@&quot;执行任务2&quot;);</span><br><span class="line"></span><br><span class="line">dispatch_sync(queue, ^&#123; // 1</span><br><span class="line">NSLog(@&quot;执行任务3&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;执行任务4&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;执行任务5&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4、GCD线程间的通信"><a href="#4、GCD线程间的通信" class="headerlink" title="4、GCD线程间的通信"></a>4、GCD线程间的通信</h3><p>在iOS开发过程中，我们一般在主线程里边进行UI刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)communication &#123;</span><br><span class="line">// 获取全局并发队列</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); </span><br><span class="line">// 获取主队列</span><br><span class="line">dispatch_queue_t mainQueue = dispatch_get_main_queue(); </span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">// 异步追加任务</span><br><span class="line">for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 回到主线程</span><br><span class="line">dispatch_async(mainQueue, ^&#123;</span><br><span class="line">// 追加在主线程中执行的任务</span><br><span class="line">[NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5、GCD的其他方法"><a href="#5、GCD的其他方法" class="headerlink" title="5、GCD的其他方法"></a>5、GCD的其他方法</h3><h4 id="5-1-GCD栅栏方法：dispatch-barrier-asnyc函数把异步操作暂时性的做成同步操作，就像一个栅栏一样分开"><a href="#5-1-GCD栅栏方法：dispatch-barrier-asnyc函数把异步操作暂时性的做成同步操作，就像一个栅栏一样分开" class="headerlink" title="5.1 GCD栅栏方法：dispatch_barrier_asnyc函数把异步操作暂时性的做成同步操作，就像一个栅栏一样分开"></a>5.1 GCD栅栏方法：<code>dispatch_barrier_asnyc</code>函数把异步操作暂时性的做成同步操作，就像一个<code>栅栏</code>一样分开</h4><img src="/2018/12/26/9-3多线程/GCD7.png" title="GCD7">
<p>就是我们在异步执行一些操作的时候，我们使用<code>dispatch_barrier_asnyc</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line"></span><br><span class="line">self.queue = dispatch_queue_create(&quot;rw_queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">[self read];</span><br><span class="line">[self read];</span><br><span class="line">[self read];</span><br><span class="line">[self write];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)read &#123;</span><br><span class="line">dispatch_async(self.queue, ^&#123;</span><br><span class="line">sleep(1);</span><br><span class="line">NSLog(@&quot;read&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)write</span><br><span class="line">&#123;</span><br><span class="line">dispatch_barrier_async(self.queue, ^&#123;</span><br><span class="line">sleep(1);</span><br><span class="line">NSLog(@&quot;write&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2018/12/26/9-3多线程/GCD8.png" title="GCD8">
<p>我们观察时间可以看到在执行<code>dispatch_barrier_asnyc</code>写操作的时候是同步执行的，不会出现异步情况</p>
<h4 id="5-2-GCD延时执行方法：dispatch-after"><a href="#5-2-GCD延时执行方法：dispatch-after" class="headerlink" title="5.2 GCD延时执行方法：dispatch_after"></a>5.2 GCD延时执行方法：dispatch_after</h4><p>我们经常会遇到这样的需求：在指定时间（例如3秒）之后执行某个任务。可以用 GCD 的dispatch_after函数来实现。<br>需要注意的是：dispatch_after函数并不是在指定时间之后才开始执行处理，而是在指定时间之后将任务追加到主队列中。严格来说，这个时间并不是绝对准确的，但想要大致延迟执行任务，dispatch_after函数是很有效的。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 延时执行方法 dispatch_after</span><br><span class="line">*/</span><br><span class="line">- (void)after &#123;</span><br><span class="line">NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">NSLog(@&quot;asyncMain---begin&quot;);</span><br><span class="line"></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">// 2.0秒后异步追加任务代码到主队列，并开始执行</span><br><span class="line">NSLog(@&quot;after---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3、GCD-一次性代码（只执行一次）：dispatch-once"><a href="#5-3、GCD-一次性代码（只执行一次）：dispatch-once" class="headerlink" title="5.3、GCD 一次性代码（只执行一次）：dispatch_once"></a>5.3、GCD 一次性代码（只执行一次）：dispatch_once</h4><p>我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了 GCD 的 dispatch_once 函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">// 只执行1次的代码(这里面默认是线程安全的)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="5-4-GCD队列组：dispatch-group"><a href="#5-4-GCD队列组：dispatch-group" class="headerlink" title="5.4 GCD队列组：dispatch_group"></a>5.4 GCD队列组：dispatch_group</h4><p>有时会我们会有这样的需求：分别异步执行2个耗时任务，然后当2个耗时任务都执行完毕后再回到主线程执行任务。这时候我们可以用到GCD的对列祖。</p>
<ul>
<li>调用队列组都<code>dipatch_group_asnyc</code>先把人物放到队列中，然后将队列放入队列组中。或者使用队列组的<code>dispatch_group_enter()</code>、<code>dispatch_group_leave</code>组合来实现<code>dispatch_group_asnyc</code>。</li>
<li>调用队列组的<code>dispatch_group_notify</code>回到指定线程执行任务。或者使用<code>dispatch_group_wait</code>回到当前线程继续向下执行（会阻塞当前线程）。</li>
<li><code>dispatch_group_enter</code>标志着一个任务追加到group，执行一次，相当于group中未执行完毕任务数+1</li>
<li><code>dispatch_group_leave</code>标志着一个任务离开了group，执行一次，相当于group中未执行完毕都任务输-1</li>
<li>当 group 中未执行完毕任务数为0的时候，才会使<code>dispatch_group_wait</code>解除阻塞，以及执行追加到<code>dispatch_group_notify</code>中的任务。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 队列组 dispatch_group_notify</span><br><span class="line">*/</span><br><span class="line">- (void)groupNotify &#123;</span><br><span class="line">NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程</span><br><span class="line">NSLog(@&quot;group---begin&quot;);</span><br><span class="line"></span><br><span class="line">dispatch_group_t group =  dispatch_group_create();</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">// 追加任务1</span><br><span class="line">for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">// 追加任务2</span><br><span class="line">for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">// 等前面的异步任务1、任务2都执行完毕后，回到主线程执行下边任务</span><br><span class="line">for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">[NSThread sleepForTimeInterval:2];              // 模拟耗时操作</span><br><span class="line">NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;group---end&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-5、GCD-信号量：dispatch-semaphore"><a href="#5-5、GCD-信号量：dispatch-semaphore" class="headerlink" title="5.5、GCD 信号量：dispatch_semaphore"></a>5.5、GCD 信号量：dispatch_semaphore</h4><p>Dispatch Semaphore 提供了三个函数。</p>
<ul>
<li><code>dispatch_semaphore_create</code>：创建一个信号量，具有整形的数值，即为信号的总量。</li>
<li><code>dispatch_semaphore_signal</code>：发送一个信号，让信号总量加1</li>
<li><code>dispatch_semaphore_wait</code>：可以使总信号量减1，当信号总量为0时就会一直等待（阻塞所在线程），否则就可以正常执行。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/26/9-2多线程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NSLegend">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/26/9-2多线程/" itemprop="url">9.2多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-26T10:35:45+08:00">
                2018-12-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS底层/" itemprop="url" rel="index">
                    <span itemprop="name">iOS底层</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="NSThread介绍"><a href="#NSThread介绍" class="headerlink" title="NSThread介绍"></a>NSThread介绍</h2><p>NSThread 是苹果官方提供的，使用起来比 pthread 更加面向对象，简单易用，可以直接操作线程对象。不过也需要需要程序员自己管理线程的生命周期(主要是创建)，我们在开发的过程中偶尔使用 NSThread。比如我们会经常调用[NSThread currentThread]来显示当前的进程信息</p>
<h4 id="NSThread的创建与运行"><a href="#NSThread的创建与运行" class="headerlink" title="NSThread的创建与运行"></a>NSThread的创建与运行</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> //使用target对象的selector作为线程的任务执行体，该selector方法最多可以接收一个参数，该参数即为argument</span><br><span class="line">- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument</span><br><span class="line"> </span><br><span class="line"> //使用block作为线程的任务执行体</span><br><span class="line"> - (instancetype)initWithBlock:(void (^)(void))block</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> /*</span><br><span class="line"> 类方法，返回值为void</span><br><span class="line"> 使用一个block作为线程的执行体，并直接启动线程</span><br><span class="line"> 上面的实例方法返回NSThread对象需要手动调用start方法来启动线程执行任务</span><br><span class="line"> */</span><br><span class="line"> + (void)detachNewThreadWithBlock:(void (^)(void))block</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> /*</span><br><span class="line"> 类方法，返回值为void</span><br><span class="line"> 使用target对象的selector作为线程的任务执行体，该selector方法最多接收一个参数，该参数即为argument</span><br><span class="line"> 同样的，该方法创建完县城后会自动启动线程不需要手动触发</span><br><span class="line"> */</span><br><span class="line"> + (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument</span><br></pre></td></tr></table></figure>
<p>简单运用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(firstThread:) object:@&quot;Hello, World&quot;];</span><br><span class="line">//设置线程的名字，方便查看</span><br><span class="line">[thread setName:@&quot;firstThread&quot;];</span><br><span class="line">//启动线程</span><br><span class="line">[thread start];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//线程的任务执行体并接收一个参数arg</span><br><span class="line">- (void)firstThread:(id)arg</span><br><span class="line">&#123;</span><br><span class="line">NSLog(@&quot;Task %@ %@&quot;, [NSThread currentThread], arg);</span><br><span class="line">NSLog(@&quot;Thread Task Complete&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2018/12/26/9-2多线程/NSThread1.png" title="NSThread1">
<h4 id="常见API"><a href="#常见API" class="headerlink" title="常见API"></a>常见API</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 获得主线程</span><br><span class="line">+ (NSThread *)mainThread;    </span><br><span class="line"></span><br><span class="line">// 判断是否为主线程(对象方法)</span><br><span class="line">- (BOOL)isMainThread;</span><br><span class="line"></span><br><span class="line">// 判断是否为主线程(类方法)</span><br><span class="line">+ (BOOL)isMainThread;    </span><br><span class="line"></span><br><span class="line">// 获得当前线程</span><br><span class="line">NSThread *current = [NSThread currentThread];</span><br><span class="line"></span><br><span class="line">// 线程的名字——setter方法</span><br><span class="line">- (void)setName:(NSString *)n;    </span><br><span class="line"></span><br><span class="line">// 线程的名字——getter方法</span><br><span class="line">- (NSString *)name;</span><br></pre></td></tr></table></figure>
<h4 id="线程状态控制方法"><a href="#线程状态控制方法" class="headerlink" title="线程状态控制方法"></a>线程状态控制方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 线程进入就绪状态 -&gt; 运行状态。当线程任务执行完毕，自动进入死亡状态</span><br><span class="line">- (void)start;</span><br><span class="line"></span><br><span class="line">// 线程进入阻塞状态</span><br><span class="line">+ (void)sleepUntilDate:(NSDate *)date;</span><br><span class="line">+ (void)sleepForTimeInterval:(NSTimeInterval)ti;</span><br><span class="line"></span><br><span class="line">//强制停止线程  线程进入死亡状态</span><br><span class="line">+ (void)exit;</span><br></pre></td></tr></table></figure>
<h4 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h4><p>在开发中，我们经常会在子线程进行耗时操作，操作结束后再回到主线程去刷新 UI。这就涉及到了子线程和主线程之间的通信。我们先来了解一下官方关于 NSThread 的线程间通信的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 在主线程上执行操作</span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;</span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray&lt;NSString *&gt; *)array;</span><br><span class="line">// equivalent to the first method with kCFRunLoopCommonModes</span><br><span class="line"></span><br><span class="line">// 在指定线程上执行操作</span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array NS_AVAILABLE(10_5, 2_0);</span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);</span><br><span class="line"></span><br><span class="line">// 在当前线程上执行操作，调用 NSObject 的 performSelector:相关方法</span><br><span class="line">- (id)performSelector:(SEL)aSelector;</span><br><span class="line">- (id)performSelector:(SEL)aSelector withObject:(id)object;</span><br><span class="line">- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;</span><br></pre></td></tr></table></figure>
<h3 id="线程的状态转换"><a href="#线程的状态转换" class="headerlink" title="线程的状态转换"></a>线程的状态转换</h3><p>当我们新建一条线程NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];，在内存中的表现为：</p>
<img src="/2018/12/26/9-2多线程/NSThread2.png" title="NSThread2">
<p>当调用[thread start];后，系统把线程对象放入可调度线程池中，线程对象进入就绪状态，如下图所示。</p>
<img src="/2018/12/26/9-2多线程/NSThread2.png" title="NSThread2">
<ul>
<li>如果CPU现在调度当前线程对象，则当前线程对象进入运行状态，如果CPU调度其他线程对象，则当前线程对象回到就绪状态。</li>
<li>如果CPU在运行当前线程对象的时候调用了sleep方法\等待同步锁，则当前线程对象就进入了阻塞状态，等到sleep到时\得到同步锁，则回到就绪状态。</li>
<li>如果CPU在运行当前线程对象的时候线程任务执行完毕\异常强制退出，则当前线程对象进入死亡状态。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/26/9-1多线程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NSLegend">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/26/9-1多线程/" itemprop="url">9.1多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-26T10:35:18+08:00">
                2018-12-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS底层/" itemprop="url" rel="index">
                    <span itemprop="name">iOS底层</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="多线程面试题"><a href="#多线程面试题" class="headerlink" title="多线程面试题"></a>多线程面试题</h2><p> 多线程有4种技术方案</p>
<table>
<thead>
<tr>
<th>技术方案</th>
<th style="text-align:center">简介</th>
<th style="text-align:center">语言</th>
<th style="text-align:center">线程的生命周期</th>
<th style="text-align:center">使用频率</th>
</tr>
</thead>
<tbody>
<tr>
<td>pthread</td>
<td style="text-align:center">一套多线程API；可跨平台使用；使用难度大</td>
<td style="text-align:center">C语言</td>
<td style="text-align:center">程序员管理</td>
<td style="text-align:center">几乎不用</td>
</tr>
<tr>
<td>NSThread</td>
<td style="text-align:center">使用面向对象；简单易用，可直接操作线程对象</td>
<td style="text-align:center">OC</td>
<td style="text-align:center">程序猿管理</td>
<td style="text-align:center">偶尔使用</td>
</tr>
<tr>
<td>GCD</td>
<td style="text-align:center">旨在替代NSThread等线程技术；充分利用设备的多核；</td>
<td style="text-align:center">C语言</td>
<td style="text-align:center">自动管理</td>
<td style="text-align:center">经常使用</td>
</tr>
<tr>
<td>NSOperation</td>
<td style="text-align:center">基于GCD（底层是GCD）；比GCD多了一些简单实用的功能；使用更加面向对象</td>
<td style="text-align:center">OC</td>
<td style="text-align:center">自动管理</td>
<td style="text-align:center">经常使用</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/21/心灵鸡汤03/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NSLegend">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/21/心灵鸡汤03/" itemprop="url">心灵鸡汤03</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-21T18:11:04+08:00">
                2018-12-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/心灵鸡汤/" itemprop="url" rel="index">
                    <span itemprop="name">心灵鸡汤</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前有个朋友，曾经告诉我，要好好追求自己的幸福。–《妖精的尾巴》乌璐</p>
<hr>
<p>这个世上确实有人很喜欢孤独，但却没有任何人能够真的承受孤独–《妖精的尾巴》马克罗夫</p>
<hr>
<p>请依靠我，我也一定会有，要依靠你的时候。痛苦的时候，悲伤的时候，我都会在你身边，你绝不是独自一人。在空中闪耀的群星，就是希望的数量；吹拂过肌肤的清风，就是明日的预感。来，踏出一步吧！伴着妖精唱出的节拍。 —-梅比斯</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/21/7-RunLoop实现原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NSLegend">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/21/7-RunLoop实现原理/" itemprop="url">7.RunLoop实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-21T10:31:05+08:00">
                2018-12-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS底层/" itemprop="url" rel="index">
                    <span itemprop="name">iOS底层</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>RunLoop 运行循环，在程序运行过程中循环做一些事情<br><strong>应用范畴</strong></p>
<ul>
<li>1、定时器（Timer）、PerformSelector</li>
<li>2、GCD </li>
<li>3、事件响应、手势识别、界面刷新</li>
<li>4、网络请求</li>
<li>5、AutoreleasePool</li>
</ul>
<h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>在我们命令行项目的<code>main</code>函数里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行完<code>NSLog(@&quot;Hello, World!&quot;);</code>这个代码以后，程序立即退出，但是在我们的正常项目<code>main</code>函数里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 如果用一个伪代码来简单的解释一下上面代码的意思，就是<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">int retVal = 0;</span><br><span class="line">do &#123;</span><br><span class="line">//休眠等待消息</span><br><span class="line">int message = sleep_and_wait();</span><br><span class="line">//处理消息</span><br><span class="line">retVal = process_message(message)</span><br><span class="line">&#125; while (0 == retVal);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 程序不会马上退出，而是保持运行状态，RunLoop的基本作用：</p>
<ul>
<li>1、保持程序持续的运行</li>
<li>2、处理app中的各种事件（比如触摸事件，定时器事件）</li>
<li>3、节省CPU资源，提高程序性能，该做事的时候做事，改休息的时候休息</li>
</ul>
<p><strong>RunLoop对象</strong><br>iOS中有2套API来访问和使用RunLoop</p>
<ul>
<li>1、Fundataion：NSRunLoop</li>
<li>2、Core Fundataion：CFRunLoop</li>
</ul>
<p><code>NSRunLoop</code>是基于<code>CFRunLoop</code>的一层OC包装，<code>CFRunLoop</code>是开源的，地址:<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/CF/</a></p>
<p><strong>RunLoop与线程</strong></p>
<ul>
<li>1、每一条线程都有唯一的一个与之对应的RunLoop对象</li>
<li>2、RunLoop保存在一个全局的Dictionary里，线程作为Key，RunLoop作为Value</li>
<li>3、线程刚创建时，并没有RunLoop对象，RunLoop会在第一次获取她时创建</li>
<li>4、RunLoop会在线程结束的时候销毁</li>
<li>5、主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop</li>
</ul>
<p><strong>获取RunLoop对象</strong></p>
<ul>
<li>1、Fundation<ul>
<li>1、获取当前线程的RunLoop对象<code>[NSRunLoop currentRunLoop]</code></li>
<li>2、获取主线程的RunLoop对象<code>[NSRunLoop mainRunLoop]</code></li>
</ul>
</li>
<li>2、Core Foundation<ul>
<li>1、获取当前线程的RunLoop对象<code>CFRunLoopGetCurrent()</code></li>
<li>2、获取主线程的RunLoop对象<code>CFRunLoopGetMain()</code></li>
</ul>
</li>
</ul>
<p><strong>RunLoop相关类</strong><br>Core Foundation中关于RunLoop一共有5个类</p>
<ul>
<li>1、CFRunLoopRef</li>
<li>2、CFRunLoopModeRef</li>
<li>3、CFRunLoopSourceRef</li>
<li>4、CFRunLoopTimerRef</li>
<li>5、CFRunLoopObserverRef</li>
</ul>
<p>我们下载<code>RunLoop</code>，然后搜索<code>CFRunLoop</code>的组成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">CFRuntimeBase _base;</span><br><span class="line">pthread_mutex_t _lock;            /* locked for accessing mode list */</span><br><span class="line">__CFPort _wakeUpPort;            // used for CFRunLoopWakeUp </span><br><span class="line">Boolean _unused;</span><br><span class="line">volatile _per_run_data *_perRunData;              // reset for runs of the run loop</span><br><span class="line">pthread_t _pthread;</span><br><span class="line">uint32_t _winthread;</span><br><span class="line">CFMutableSetRef _commonModes;</span><br><span class="line">CFMutableSetRef _commonModeItems;</span><br><span class="line">CFRunLoopModeRef _currentMode;</span><br><span class="line">CFMutableSetRef _modes;</span><br><span class="line">struct _block_item *_blocks_head;</span><br><span class="line">struct _block_item *_blocks_tail;</span><br><span class="line">CFAbsoluteTime _runTime;</span><br><span class="line">CFAbsoluteTime _sleepTime;</span><br><span class="line">CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们打印一下<code>NSLog(@&quot;%@&quot;,[NSRunLoop currentRunLoop]);</code></p>
<p>其中主要的有下面几个<br><img src="/2018/12/21/7-RunLoop实现原理/RunLoop1.png" title="RunLoop1"></p>
<ul>
<li>1、<code>_pthread</code>记录当前线程</li>
<li>2、<code>_commonModes</code></li>
<li>3、<code>_commonModeItems</code></li>
<li>4、<code>_currentMode</code>,当前mode类型</li>
<li>5、<code>_modes</code> 存放CFRunLoop里面的所有mode</li>
</ul>
<p>我们在RunLoop源码中搜索<code>CFRunLoopMode</code>来查看一下CFRunLoopMode都存放了哪些东西</p>
<img src="/2018/12/21/7-RunLoop实现原理/RunLoop2.png" title="RunLoop2">
<ul>
<li>1、Source0：<ul>
<li>处理触摸事件，</li>
<li>performSelector:onThread:</li>
</ul>
</li>
<li>2、Source1：<ul>
<li>基于Port的线程间通信，</li>
<li>系统事件的捕捉</li>
</ul>
</li>
<li>3、Timer ：<ul>
<li>NSTimer，</li>
<li>performSelector:withObject:afterDelay:</li>
</ul>
</li>
<li>4、Observers：<ul>
<li>用于监听RunLoop的状态</li>
<li>UI刷新</li>
<li>Autorelease pool（BeforeWaiting）</li>
</ul>
</li>
</ul>
<p>我们来简单的证明一下<code>Source0</code>,我们随便写一个<code>touchesBegan</code>触摸事件，然后在里面打一个断点，<code>bt</code>指令就是打印线程执行的所有方法</p>
<img src="/2018/12/21/7-RunLoop实现原理/RunLoop4.png" title="RunLoop4">
<p>我们可以在线程执行方法中可以发现，在调用RunLoop相关方法的时候，第一个是调用的<code>__CFRunLoopDoSources0</code></p>
<p>RunLoop里面会有多个Mode，但是只有一个<code>_currentMode</code></p>
<img src="/2018/12/21/7-RunLoop实现原理/RunLoop3.png" title="RunLoop3">
<p><strong>CFRunLoopModeRef</strong></p>
<ul>
<li>1、CFRunLoopModeRef代表着RunLoop的运行模式</li>
<li>2、一个RunLoop包含若干个<code>Mode</code>，每个<code>Mode</code>又包含若干个<code>Source0/Source1/Timer/Observer</code></li>
<li>3、RunLoop启动的时候只能选择其中一个Mode作为currentMode</li>
<li>4、如果要切换Mode，只能退出当前Loop，再重新选择一个Mode进入，不同组的<code>Source0/Source1/Timer/Observer</code>互不影响</li>
<li>5、如果Mode里面没有任何<code>Source0/Source1/Timer/Observer</code>，RunLoop会立刻退出</li>
</ul>
<p><strong>CFRunLoopModeRef常见的Mode</strong></p>
<ul>
<li>1、KCFRunLoopDefaultMode（NSDefaultRunLoopMode）：App的默认Mode，通常主线程是在这个Mode下运行的</li>
<li>2、UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li>
</ul>
<p>获取当前Mode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopMode mode = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());</span><br></pre></td></tr></table></figure></p>
<p><strong>CFRunLoopObserverRef</strong></p>
<p>RunLoop的几种状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Run Loop Observer Activities */</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">kCFRunLoopEntry = (1UL &lt;&lt; 0), //即将进入runloop</span><br><span class="line">kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), //即将处理timer</span><br><span class="line">kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即将处理source</span><br><span class="line">kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠</span><br><span class="line">kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),  //刚从休眠中唤醒</span><br><span class="line">kCFRunLoopExit = (1UL &lt;&lt; 7),          //即将退出Loop</span><br><span class="line">kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以添加一个Observer监听RunLoop的所有状态，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 创建Observer</span><br><span class="line">CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">switch (activity) &#123;</span><br><span class="line">case kCFRunLoopEntry:</span><br><span class="line">NSLog(@&quot;kCFRunLoopEntry&quot;);</span><br><span class="line">break;</span><br><span class="line">case kCFRunLoopBeforeTimers:</span><br><span class="line">NSLog(@&quot;kCFRunLoopBeforeTimers&quot;);</span><br><span class="line">break;</span><br><span class="line">case kCFRunLoopBeforeSources:</span><br><span class="line">NSLog(@&quot;kCFRunLoopBeforeSources&quot;);</span><br><span class="line">break;</span><br><span class="line">case kCFRunLoopBeforeWaiting:</span><br><span class="line">NSLog(@&quot;kCFRunLoopBeforeWaiting&quot;);</span><br><span class="line">break;</span><br><span class="line">case kCFRunLoopAfterWaiting:</span><br><span class="line">NSLog(@&quot;kCFRunLoopAfterWaiting&quot;);</span><br><span class="line">break;</span><br><span class="line">case kCFRunLoopExit:</span><br><span class="line">NSLog(@&quot;kCFRunLoopExit&quot;);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 添加Observer到RunLoop中</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line">// 释放</span><br><span class="line">CFRelease(observer);</span><br></pre></td></tr></table></figure></p>
<p>我们运行上面代码，然后查看打印结果</p>
<img src="/2018/12/21/7-RunLoop实现原理/RunLoop6.png" title="RunLoop6">
<p>在没有任何事件处理的情况下，最终RunLoop的活动状态为<code>kCFRunLoopBeforeWaiting</code>即将进入休眠</p>
<p>既然我们可以监听到了<code>RunLoop</code>的<code>Mode</code>变化情况，那么我们就可以打印一下<code>KCFRunLoopDefaultMode</code>和<code>UITrackingRunLoopMode</code>的切换情况了</p>
<p>我们在view上随便拉一个<code>UITextView</code>,然后滚动<code>UITextView</code><br>监听代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//创建observer</span><br><span class="line">CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">switch (activity) &#123;</span><br><span class="line">case kCFRunLoopEntry: &#123;</span><br><span class="line">CFRunLoopMode mode = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());</span><br><span class="line">NSLog(@&quot;kCFRunLoopEntry - %@&quot;, mode);</span><br><span class="line">CFRelease(mode);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case kCFRunLoopExit: &#123;</span><br><span class="line">CFRunLoopMode mode = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());</span><br><span class="line">NSLog(@&quot;kCFRunLoopExit - %@&quot;, mode);</span><br><span class="line">CFRelease(mode);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//添加observer到runloop中</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line">// 释放</span><br><span class="line">CFRelease(observer);</span><br></pre></td></tr></table></figure></p>
<p>打印结果为</p>
<img src="/2018/12/21/7-RunLoop实现原理/RunLoop5.png" title="RunLoop5">
<ul>
<li>1、在刚开始滚动<code>UITextView</code>的时候，先退出<code>kCFRunLoopDefaultMode</code>，所以默认应该就是<code>kCFRunLoopDefaultMode</code></li>
<li>2、在滚动中，进入<code>UITrackingRunLoopMode</code></li>
<li>3、在滚动结束，先退出<code>UITrackingRunLoopMode</code>，然后在进入<code>kCFRunLoopDefaultMode</code></li>
</ul>
<h3 id="RunLoop的运行逻辑"><a href="#RunLoop的运行逻辑" class="headerlink" title="RunLoop的运行逻辑"></a>RunLoop的运行逻辑</h3><img src="/2018/12/21/7-RunLoop实现原理/RunLoop7.png" title="RunLoop7">
<p>每次运行RunLoop，线程的RunLoop会自动处理之前未处理的消息，并通知相关的观察者。具体顺序</p>
<ul>
<li>1、通知观察者（observers）RunLoop即将启动</li>
<li>2、通知观察者（observers）任何即将要开始的定时器</li>
<li>3、通知观察者（observers）即将处理source0事件</li>
<li>4、处理source0</li>
<li>5、如果有source1，跳到第9步</li>
<li>6、通知观察者（observers）线程即将进入休眠</li>
<li>7、将线程置于休眠知道任一下面的事件发生<ul>
<li>1、source0事件触发</li>
<li>2、定时器启动</li>
<li>3、外部手动唤醒</li>
</ul>
</li>
<li>8、通知观察者（observers）线程即将唤醒</li>
<li>9、处理唤醒时收到的时间，之后跳回2<ul>
<li>1、如果用户定义的定时器启动，处理定时器事件</li>
<li>2、如果source0启动，传递相应的消息</li>
</ul>
</li>
<li>10、通知观察者RunLoop结束</li>
</ul>
<p><strong>RunLoop休眠原理</strong></p>
<img src="/2018/12/21/7-RunLoop实现原理/RunLoop8.png" title="RunLoop8">
<p>在RunLoop即将休眠的时候，通过<code>mach_msg()</code>方法来让软件和硬件交互</p>
<ul>
<li>1、即将休眠的时候，程序调用<code>mach_msg()</code>传递给CPU，告诉CPU停止运行</li>
<li>2、即将启动RunLoop的时候，程序调用<code>mach_msg()</code>传递给CPU，告诉CPU开始工作</li>
</ul>
<h3 id="RunLoop简单应用"><a href="#RunLoop简单应用" class="headerlink" title="RunLoop简单应用"></a>RunLoop简单应用</h3><h4 id="滚动视图上面NSTimer不失效"><a href="#滚动视图上面NSTimer不失效" class="headerlink" title="滚动视图上面NSTimer不失效"></a>滚动视图上面NSTimer不失效</h4><p>我们写一个简单的定时器,然后视图上面创建一个TextView,然后滚动TextView<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static int count = 0;</span><br><span class="line">[NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">NSLog(@&quot;%d&quot;,count++);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<img src="/2018/12/21/7-RunLoop实现原理/RunLoop9.png" title="RunLoop9">
<p>我们观察可以发现在打印的第二秒和第三秒之间其实相差了<code>5s</code>，因为一个线程只会有一个RunLoop，默认情况下是<code>kCFRunLoopDefaultMode</code>，在滚动<code>UITextView</code>的时候，RunLoop切换到了<code>UITrackingRunLoopMode</code>,这个时候定时器就会停止，在滚动<code>UITextView</code>结束的时候，RunLoop切换到了<code>kCFRunLoopDefaultMode</code>，定时器继续开始启动了。</p>
<p>解决这个问题的方法就是把这个<code>NSTimer</code>添加到两种RunLoop中</p>
<ul>
<li><p>1、</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</span><br></pre></td></tr></table></figure>
</li>
<li><p>2、还有一个NSRunLoopCommonModes，我们用<code>NSRunLoopCommonModes</code>标记的时候，就可以实现上面效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>NSRunLoopCommonModes并不是一个真的模式，它只是一个标记,timer能在_commonModes数组中存放的模式下工作</p>
<h4 id="线程保活-常驻线程"><a href="#线程保活-常驻线程" class="headerlink" title="线程保活(常驻线程)"></a>线程保活(常驻线程)</h4><p>开始之前先介绍几个概念</p>
<ul>
<li>1、线程刚创建时，并没有RunLoop对象，RunLoop会在第一次获取她时创建<ul>
<li>1、获取线程：[NSRunLoop currentRunLoop]</li>
<li>2、获取线程：CFRunLoopGetCurrent()</li>
</ul>
</li>
<li>2、启动RunLoop的三种方法<ul>
<li>1、<code>- (void)run;</code>,<br>  这种方法runloop会一直运行下去，在此期间会处理来自输入源的数据，并且会在NSDefaultRunLoopMode模式下重复调用runMode:beforeDate:方法；</li>
<li>2、<code>- (void)runUntilDate:(NSDate *)limitDate；</code><br>  可以设置超时时间，在超时时间到达之前，runloop会一直运行，在此期间runloop会处理来自输入源的数据，并且也会在NSDefaultRunLoopMode模式下重复调用runMode:beforeDate:方法；</li>
<li>3、<code>- (void)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;</code><br>  runloop会运行一次，超时时间到达或者第一个input source被处理，则runloop就会退出</li>
</ul>
</li>
<li>3、退出RunLoop的方式<ul>
<li>1、启动方式的退出方法，如果runloop没有input sources或者附加的timer，runloop就会退出。</li>
<li>2、启动方式runUntilDate，可以通过设置超时时间来退出runloop。</li>
<li>3、启动方式runMode:beforeDate，通过这种方式启动，runloop会运行一次，当超时时间到达或者第一个输入源被处理，runloop就会退出。</li>
</ul>
</li>
</ul>
<p>如果我们想控制runloop的退出时机，而不是在处理完一个输入源事件之后就退出，那么就要重复调用runMode:beforeDate:，<br>具体可以参考苹果文档给出的方案，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSRunLoop *myLoop  = [NSRunLoop currentRunLoop];</span><br><span class="line">myPort = (NSMachPort *)[NSMachPort port];</span><br><span class="line">[myLoop addPort:_port forMode:NSDefaultRunLoopMode];</span><br><span class="line"></span><br><span class="line">BOOL isLoopRunning = YES; // global</span><br><span class="line"></span><br><span class="line">while (isLoopRunning &amp;&amp; [myLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//关闭runloop的地方</span><br><span class="line">- (void)quitLoop</span><br><span class="line">&#123;</span><br><span class="line">isLoopRunning = NO;</span><br><span class="line">CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做了一个简单的RunLoop的封装，我们可以更加方便的时候保活线程，并且能够及时的销毁,需要的可以点击<a href="https://github.com/SunshineBrother/JHBlog/tree/master/iOS知识点/RunLoop封装" target="_blank" rel="noopener">这里</a></p>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>1、讲讲RunLoop项目中有用到吗？</p>
<ul>
<li>1、定时器切换的时候，为了保证定时器的准确性，需要添加runLoop</li>
<li>2、在聊天界面，我们需要持续的把聊天信息存到数据库中，这个时候需要开启一个保活线程，在这个线程中处理</li>
</ul>
<p>2、RunLoop内部实现逻辑？</p>
<ul>
<li>1、通知观察者（observers）RunLoop即将启动</li>
<li>2、通知观察者（observers）任何即将要开始的定时器</li>
<li>3、通知观察者（observers）即将处理source0事件</li>
<li>4、处理source0</li>
<li>5、如果有source1，跳到第9步</li>
<li>6、通知观察者（observers）线程即将进入休眠</li>
<li>7、将线程置于休眠知道任一下面的事件发生</li>
<li>1、source0事件触发</li>
<li>2、定时器启动</li>
<li>3、外部手动唤醒</li>
<li>8、通知观察者（observers）线程即将唤醒</li>
<li>9、处理唤醒时收到的时间，之后跳回2</li>
<li>1、如果用户定义的定时器启动，处理定时器事件</li>
<li>2、如果source0启动，传递相应的消息</li>
<li>10、通知观察者RunLoop结束</li>
</ul>
<p>3、RunLoop和线程的关系？</p>
<ul>
<li>1、每一条线程都有唯一的一个与之对应的RunLoop对象</li>
<li>2、RunLoop保存在一个全局的Dictionary里，线程作为Key，RunLoop作为Value</li>
<li>3、线程刚创建时，并没有RunLoop对象，RunLoop会在第一次获取她时创建</li>
<li>4、RunLoop会在线程结束的时候销毁</li>
<li>5、主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop</li>
</ul>
<p>4、RunLoop有几种状态</p>
<p>kCFRunLoopEntry = (1UL &lt;&lt; 0),   //   即将进入RunLoop<br>kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理Timer<br>kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理Source<br>kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠<br>kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),// 刚从休眠中唤醒<br>kCFRunLoopExit = (1UL &lt;&lt; 7),// 即将退出RunLoop</p>
<p>5、RunLoop的mode的作用<br>系统注册了5中mode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kCFRunLoopDefaultMode //App的默认Mode，通常主线程是在这个Mode下运行</span><br><span class="line">UITrackingRunLoopMode //界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</span><br><span class="line">UIInitializationRunLoopMode // 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用</span><br><span class="line">GSEventReceiveRunLoopMode // 接受系统事件的内部 Mode，通常用不到</span><br><span class="line">kCFRunLoopCommonModes //这是一个占位用的Mode，不是一种真正的Mode</span><br></pre></td></tr></table></figure></p>
<p>但是我们只能使用两种mode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kCFRunLoopDefaultMode //App的默认Mode，通常主线程是在这个Mode下运行</span><br><span class="line">UITrackingRunLoopMode //界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</span><br></pre></td></tr></table></figure></p>
<p><a href="https://www.jianshu.com/p/d260d18dd551" target="_blank" rel="noopener">iOS 多线程：『RunLoop』详尽总结</a></p>
<p><a href="http://www.cocoachina.com/ios/20180515/23380.html" target="_blank" rel="noopener">iOS RunLoop入门小结</a></p>
<p><a href="https://www.jianshu.com/p/f3079ea36775" target="_blank" rel="noopener">iOS-Runloop常驻线程／性能优化</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/headIcon.png" alt="NSLegend">
            
              <p class="site-author-name" itemprop="name">NSLegend</p>
              <p class="site-description motion-element" itemprop="description">Stay Hungry,Stay Foolish.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">42</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/WSGNSLog" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/ba5f297de9bc" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-heartbeat"></i>简书</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NSLegend</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
